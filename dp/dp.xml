<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" 
   "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY % fithesis SYSTEM "http://www.fi.muni.cz/~xpavlov/fithesis.mod">
   %fithesis; ]>

<book lang="cs" xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">

<bookinfo>
    <title>Generování rostlin pomocí L-systémů</title>
    <subtitle>Diplomová práce</subtitle>
    <author>
        <firstname>Marek</firstname>
        <surname>Pasičnyk</surname>
        <fi:woman>false</fi:woman>
        <fi:faculty>fi</fi:faculty>
        <fi:advisor>RNDr. Vít Kovalčík, Ph.D.</fi:advisor>
    </author>
    <pubdate>jaro 2010</pubdate>
    <fi:thanks><para>Chtěl bych poděkovat 
    </para></fi:thanks>
    <abstract>
        <para>
        Tato práce se zabývá problematikou Lindenmayerových systémů, jakožto nástroje pro generování rostlin. Rozebírá pak také metody a implementaci L-systémů a jejich grafickou interpretaci. Součástí je i zásuvný modul pro generování rostlin pro systém Vrecko.
        </para>
    </abstract>
    <keywordset>
   		<keyword>Lindenmayerovy systémy</keyword>
   		<keyword>L-systémy</keyword>
      <keyword>generování rostlin</keyword>
      <keyword>generování stromů</keyword>
      <keyword>Vrecko</keyword>
      <keyword>OpenSceneGraph</keyword>
      <keyword>LSystem</keyword>
    </keywordset>
</bookinfo>

<toc/>

<chapter id="ch01">
  <title>Úvod</title>
  <para>
    Snaha převést přírodu do digitální podoby provází počítačovou grafiku již od samého počátku. Po celou tuto dobu je zpracování přírodních procesů jednou z nejvíce studovaných a&nbsp;tedy i rozvíjejících se oblastí. Od počátku totiž byly přírodní procesy příliš složité, než aby bylo možné vytvořit je pomocí počítače bez jakéhokoli zpracování a zjednodušení. Zároveň jsou však součástí téměř každé animace, filmu, simulace či počítačové hry. Díky tomu vzniklo za posledních padesát let od vynálezu světelného pera Ivana Sutherlanda, tedy od počátku moderní počítačové grafiky, obrovské množství více či méně úspěšných metod. Proto také dnes ty nejmodernější metody umožňují někdy i fotorealistické zpracování modelů nebo simulaci různých přírodních jevů graficky i fyzikálně. S určitými omezeními je to navíc možné i v reálném čase. V tomto vývoji samozřejmě hrál velkou roli i vývoj samotné počítačové techniky.
  </para>
  <para>
    První pokusy o vytvoření počítačových modelů rostlinných organismů pochází z roku 1966, kdy Stanislaw Ulman přišel s prvním mechanismem pro vytváření větvených struktur. Využil k tomu principu von Neumannova <emphasis>celulárního automatu</emphasis>. Zanedlouho však Aristid Lindenmayer publikoval koncept Lindenmayerových systémů, které se později staly nejpoužívanější metodou pro generování rostlinných organismů. Během posledních 45 let se z generování rostlin stal jeden z důležitých mezivědních oborů. Na jedné straně vždy stáli biologové, jež se za pomocí počítačových modelů a simulací snažili pochopit principy vývoje a stavby rostlin. Na druhé straně jsou pak specialisti na počítačovou grafiku, jež stromy používají jako součást grafických scén. Kombinací poznatků obou vědních oborů tak vznikají stále nové metody. Výsledkem je, že modely rostlin jsou dnes často těžko rozeznatelné od svých opravdových protějšků.   
  </para>
  <para>
    Tato diplomová práce se věnuje modelování rostlinných organismů za použití Lindenmayerových systémů. Cílem bylo navrhnout zásuvný modul LSystem pro systém Vrecko. Tento modul umožňuje na základě uživatelsky definovaných parametrů vytvořit širokou škálu různých modelů. Implementován totiž není pouze původní Lindenmayerův koncept, ale také řada metod, jež jej rozšiřuje o další možnosti. Modely tak mohou například reagovat na okolní prostředí. Lindenmayerovy systémy lze díky jejich všestranosti použít i pro vytváření různých neorganických modelů. Většina zde zmíněných metod je použitelná pro vytvoření libovolného rostlinného organismu. Při implementaci modulu LSystem však byl kladen důraz na vytváření modelů stromů a keřů, jež pak mohou být použity pro vytváření venkovních scén v systému Vrecko.
  </para>
  <para>
    Začátek této diplomové práce se věnuje především samotným Lindenmayerovým systémům, jejich typům a možnostem. Třetí kapitola pak rozebírá problematiku modelování rostlinných organismů. Zbývající kapitoly se již věnují samotnému návrhu a implementaci zásuvného modulu LSystem. Čtvrtá kapitola se zabývá obecným popisem modulu. Následující pátá kapitola pak obsahuje popis implementace generování řetězců pomocí L-systémů. Interpretace řetězců a vytváření samotné geometrie modelů je pak obsahem šesté kapitoly. Práci  uzavírá sedmá kapitola shrnující výkonnostní i zobrazovací výsledky.
  </para>
</chapter>

<chapter id="ch02">
  <title>Lindenmayerovy systémy</title>
  <para>
Lindenmayerovy systémy, zkráceně L-systémy, byly vytvořeny jako matematická teorie pro generování rostlin <citation>Linden68</citation>. Původně byl kladen důraz spíše na obecnou topologii. Byly totiž vytvořeny pro simulaci vývoje větších částí rostlin nebo buněk mnohobuněčných organismů. Geometrie ani podrobnější detaily  v této původní teorii zahrnuty nebyly. Později se však objevilo několik geometrických interpretací L-systémů, díky nimž se staly L-systémy univerzálním nástrojem pro simulaci a modelování rostlin. V této práci je například použito modelování pomocí želví grafiky.
	</para>
	<para>
    Lindemayerovy systémy však nenalezly uplatnění zdaleka jen v generování rostlinných organismů. Existuje řada projektů, jež různými způsoby experimentuje s použitím L-systémů.  
  </para>
  <sect1 id="sec0201">
    <title>Vývoj rostlin pomocí procesu přepisování</title>
		<para>
Jádro L-systémů spočívá v použití přepisovacího systému. Jedná se o opakované nahrazování modulů předchůdců pomocí sady přepisovacích pravidel jejich následníky, přičemž následník je řetězec modulů. Všechny moduly náleží do konečné abecedy modulů. Lze tak z jednoduchého původního objektu vytvořit opakováním přepisovacího procesu komplexní model. Modulem je myšlen libovolný objekt, jež většinou reprezentuje nějakou část simulovaného modelu nebo jeho vlastnost. Při použití pro simulaci biologických procesů se tak může jednat například o buňky nebo různé typy rostlinných orgánů. 
    </para>
    <para>
Jedním z prvních grafických modelů, používajících přepisovací pravidla, byla Kochova křivka, případně Kochova vločka <citation>Koch05</citation>. Šlo o jednoduchý bezkontextový přepisovací systém, který obsahoval pouze jediné pravidlo přepisující jeden grafický prvek na jiný (<xref linkend="pic020101"/>). Později tento model podstatně rozšířil Benoît Mandelbrot, jež přidal systémy podporující přepisování úseček o různých délkách a hlavně podporu větvených topologií.
		</para>
		<para>
		  <figure float="1" id="pic020101">
        <title>Kochova vločka a její první tři iterace přepisovacího procesu.</title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="020102.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>
		</para>
		<para>
Největší pozornost však byla ubírána ke studiu systémů založených na přepisování řetězců znaků. Velkým přínosem v tomto odvětví byly na konci padesátých let 20. století Chomského formální gramatiky, které využívaly princip přepisování pro popis syntaxe přirozeného jazyka. V roce 1968 pak biolog Aristid Lindenmayer představil odlišný typ mechanismu přepisujícího řetězce. Tento mechanismus byl posléze pojmenován jako L-systémy. Zásadní odlišnost L-systémů od Chomského gramatik spočívá v použití přepisovacích pravidel. Zatímco v Chomského gramatikách jsou přepisovací pravidla aplikována postupně, v L-systémech jsou použita paralelně v jednom derivačním kroku na všechny symboly přepisovaného řetězce. Motivací pro tento přístup byla podobnost s biologickými procesy. Příkladem mohou být mnohobuněčné organismy, ve kterých se dělí všechny buňky současně. Na rozdíl od přírodních pochodů vývoj L-systémů probíhá v diskrétních krocích. Kvůli reprezentaci modelů jako řetězce znaků se často místo pojmu modul používá pojem symbol.		
   	</para>
  </sect1>
  <sect1 id="sec0202">
    <title>D0L-systémy</title>
    <para>
Deterministické bezkontextové L-systémy, zkráceně D0L-systémy,jsou nejjednodušší formou L-systémů. Původní Lindenmayerovy systémy zahrnovaly právě pouze tento typ. Takovýto typ L-systému se skládá z abecedy modulů, přepisovacích pravidel a axiomu, jež slouží jako počáteční řetězec modulů. Na obrázku <xref linkend="pic020201"/> je znázorněna simulace vývoje mnohobuněčného vlákna buněk nacházející se v bakterii Anabaena catenula <citation>Mitch1972</citation>. Tyto řetězce jsou tvořeny dvěma typy buněk. Prvním typem jsou mladé, kratší buňky. Druhý typ jsou buňky starší a delší. Každá buňka má také svou polaritu, která určuje směr jejich růstu.
    </para>
    <para>
		  <figure float="1" id="pic020201">
        <title>První tři iterace vlákna buňky <emphasis>Anabaena catenula</emphasis></title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="020201.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>
		</para>
    <para>
    Formální definice D0L-systémů je následující <citation>Rozen1980</citation>:
    <itemizedlist mark='opencircle'>
      <listitem>
        <para>
Abeceda <emphasis>V</emphasis> je konečná množina <emphasis>symbolů</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
<emphasis>Slovo</emphasis> je posloupnost symbolů nad abecedou <emphasis>V</emphasis>. Množina všech těchto posloupností se označuje jako <emphasis>V*</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Přepisovací pravidlo</emphasis> je uspořádaná dvojice 
          <inlineequation>
             <alt role="tex">(a,u)</alt>
             <graphic fileref="math020101.png"/>
          </inlineequation>
          zapsaná jako 
          <inlineequation>
             <alt role="tex">a \to u</alt>
             <graphic fileref="math020102.png"/>
          </inlineequation>          
          , kde 
          <inlineequation>
             <alt role="tex">a</alt>
             <graphic fileref="math020103.png"/>
          </inlineequation>
          je symbol náležící <emphasis>V</emphasis> a
          <inlineequation>
             <alt role="tex">u</alt>
             <graphic fileref="math020104.png"/>
          </inlineequation>
          je slovo náležící <emphasis>V*</emphasis>. Symbol 
          <inlineequation>
             <alt role="tex">a</alt>
             <graphic fileref="math020105.png"/>
          </inlineequation>
          se nazývá <emphasis>předchůdce</emphasis> a slovo 
          <inlineequation>
            <alt role="tex">u</alt>
            <graphic fileref="math020106.png"/>
          </inlineequation>
          <emphasis>následník</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>D0L-systém</emphasis> je uspořádaná trojice
          <inlineequation>
             <alt role="tex">G= \langle V, \omega ,P \rangle</alt>
             <graphic fileref="math020107.png"/>
          </inlineequation>, kde <emphasis>V</emphasis> je abeceda,
          <inlineequation>
             <alt role="tex">\omega \in </alt>
             <graphic fileref="math020108.png"/>
          </inlineequation>
          <emphasis>V*</emphasis> je počáteční slovo nazývané <emphasis>axiom</emphasis> a <emphasis>P</emphasis> je množina přepisovacích pravidel takových, že pro
          <inlineequation>
             <alt role="tex">\forall a \in V: \exists p_{a} \in P</alt>
             <graphic fileref="math020109.png"/>
          </inlineequation>, kde
          <inlineequation>
             <alt role="tex">p_{a}</alt>
             <graphic fileref="math020110.png"/>
          </inlineequation>
          označuje přepisovací pravidlo, jehož předchůdce je modul
          <inlineequation>
             <alt role="tex">a</alt>
             <graphic fileref="math020111.png"/>
          </inlineequation>.
        </para>
      </listitem>
    </itemizedlist>
    Dle obecných konvencí bývá přepisovací pravidlo
    <inlineequation>
     <alt role="tex">a \to u</alt>
     <graphic fileref="math020112.png"/>
    </inlineequation>
    označováno jako odpovídající modulu
    <inlineequation>
      <alt role="tex">a</alt>
    </inlineequation> 
    a pro modul, kterému neodpovídá žádné z přepisovacích pravidel, bývá použito pravidlo identity
    <inlineequation>
     <alt role="tex">a \to a</alt>
     <graphic fileref="math020113.png"/>
    </inlineequation>
    . Modul je možné během vývoje L-systému odstranit pomocí použití
    <inlineequation>
     <alt role="tex">\epsilon</alt>
     <graphic fileref="math020114.png"/>
    </inlineequation>
    pravidla.
    </para>  
    <para>
      Dle této definice je pak možné pro vývoj vláken bakterie Anabaena zavést L-systém, jež popisuje jeho vývoj. V těchto pravidlech nahrazují delší buňky moduly 
      <inlineequation>
        <alt role="tex">a</alt>
      </inlineequation>
      a kratší buňky moduly 
      <inlineequation>
        <alt role="tex">b</alt>
      </inlineequation>. 
      Index u modulů označuje jejich orientaci.
    </para> 
    <para>
      <inlineequation>
        <alt role="tex">\omega : a_p</alt>
      </inlineequation>  
    </para>
    <para>
      <inlineequation>
        <alt role="tex">p_1 : a_p \to a_l b_p</alt>
      </inlineequation>  
    </para>
    <para>
      <inlineequation>
        <alt role="tex">p_2 : a_l \to b_l a_p</alt>
      </inlineequation>  
    </para>
    <para>
      <inlineequation>
        <alt role="tex">p_3 : b_p \to a_p</alt>
      </inlineequation>  
    </para>
    <para>
      <inlineequation>
        <alt role="tex">p_4 : b_l \to a_l</alt>
      </inlineequation>  
    </para>
  </sect1>
  
  
  <sect1 id="sec0203">
    <title>L-systémy se závorkami</title>
    <para>
    Obecné D0L-systémy poskytují možnosti pouze pro vytvoření sekvence modulů. Aby však bylo možné vytvořit slova reprezentující rostliny, je nutné umožnit L-systémům vytvářet větvené topologie. Pro reprezentaci větvených struktur je potřeba zavést dva moduly. Tyto moduly byly již součástí původního Lindenmayerova konceptu <citation>Linden68</citation>. Pro označení začátku a konce vedlejší větve se používají symboly pravé a levé hranaté závorky.
    </para>
    <figure float="1" id="pic020301">
      <title>První tři iterace vlákna buňky <emphasis>Anabaena catenula</emphasis></title>
	  	<mediaobject>
        <imageobject>
			    <imagedata fileref="020301.jpg" format="JPG"/>
	      </imageobject>
      </mediaobject>
	  </figure>
    <para>
    Slova, vyprodukovaná derivacemi přepisovacích pravidel závorkového L-systému, se označují jako stromy. Příklad takovéto stromové struktury vytvořené L-systémem se závorkami je na obrázku <xref linkend="pic020301"/>. Jedná se o základní větvenou strukturu s jednou hlavní osou tvořenou moduly 
    <inlineequation>
      <alt role="tex">aehik</alt>
    </inlineequation>
    . Slovo reprezentující tento strom lze pomocí jednoho řetězce zapsat jako 
      <inlineequation>
        <alt role="tex">w = a[b[c]d]e[fg]hi[j]k</alt>
        <graphic fileref="math020301.png"/>
      </inlineequation>.
    </para>
    <para>
      Řetězce modulů 
      <inlineequation>
        <alt role="tex">a</alt>
      </inlineequation>, 
      <inlineequation>
        <alt role="tex">e</alt>
      </inlineequation> 
      a 
      <inlineequation>
        <alt role="tex">hi</alt>
      </inlineequation> 
      se označují jako meziuzly a řetězce 
      <inlineequation>
        <alt role="tex">b[c]d</alt>
      </inlineequation>, 
      <inlineequation>
        <alt role="tex">fg</alt>
      </inlineequation> 
      a 
      <inlineequation>
        <alt role="tex">j</alt>
      </inlineequation> 
      jako vedlejší větve. Modul 
      <inlineequation>
        <alt role="tex">k</alt>
      </inlineequation> 
      je hrotem hlavní osy. Obdobně lze pojmenovat i moduly na nižších úrovních a označit  tak například moduly 
      <inlineequation>
        <alt role="tex">c</alt>
      </inlineequation>, 
      <inlineequation>
        <alt role="tex">d</alt>
      </inlineequation>, 
      <inlineequation>
        <alt role="tex">g</alt>
      </inlineequation>
      a
      <inlineequation>
        <alt role="tex">j</alt>
      </inlineequation>
      jako hroty vedlejších větví. 
    </para>  
    <para>    
      Strom lze podle <citation>Prusin94</citation> definovat jako slovo 
      <inlineequation>
        <alt role="tex">w</alt>
      </inlineequation>
      nad abecedou 
      <inlineequation>
        <alt role="tex">V_{E} = V \cup \{ [,] \}</alt>
        <graphic fileref="math020301.png"/>
      </inlineequation> 
      pro které platí, že
      <itemizedlist mark='opencircle'>
        <listitem>
          <para>
            <inlineequation>
              <alt role="tex">w = x_{1}[a_{1}]x_{2}[a_{2}]...x_{n}[a_{n}]x_{n+1}</alt>
              <graphic fileref="math020301.png"/>
            </inlineequation>,
          </para>
        </listitem>
        <listitem>
          <para>
            podslova
            <inlineequation>
              <alt role="tex">x_{1},x_{2},...,x_{n+1} \in V^*</alt>
              <graphic fileref="math020402.png"/>
            </inlineequation>
             neobsahují moduly závorek a
          </para>
        </listitem>
        <listitem>
          <para>
            podslova
            <inlineequation>
              <alt role="tex">a_1,a_2,...,a_n \in V_{E}^*</alt>
              <graphic fileref="math020402.png"/>
            </inlineequation>
            jsou stromy.
          </para>
        </listitem>
      </itemizedlist> 
    </para>
  </sect1>
  <sect1 id="sec0204">
    <title>Kontextové L-systémy</title>
    <para>  
Přepisování pravidel u 0L-systémů je bezkontextové. Při produkci následníků tedy nezáleží na modulech v okolí předchůdce. Při přepisování kontextových L-systémů však musí kromě předchůdců odpovídat také jejich sousední moduly. Tímto způsobem mohou mezi sebou jednotlivé moduly komunikovat nebo posílat ostatním modulům signály. Lze tak simulovat reakci na proudění látek rostlinou nebo informovat moduly o globálních vlastnostech celého L-systému, jako je délka stonku, počet květů, stáří apod. Moduly však takto mohou komunikovat i s okolím L-systému a získávat tak informace například o množství světla, množství živin, ročním období nebo překážce v růstu. 
    </para>
    <para>
Existuje mnoho implementací kontextových L-systémů. Nejpoužívanější jsou 1L-systémy a 2L-systémy. U 1L-systémů je brán zřetel buď pouze na levý nebo pouze na pravý kontext modulu předchůdce. Zápis pravidel s jednostranným kontextem tedy může být ve tvaru
    </para>
    <para>
      <simplelist type="vert" columns="1">
        <member> </member>
        <member>
          <emphasis>lk &lt; předchůdce 
          <inlineequation>
            <alt role="tex">\to</alt>
          </inlineequation>
          následník
          </emphasis>
          nebo
          <emphasis>předchůdce > pk
          <inlineequation>
            <alt role="tex">\to</alt>
          </inlineequation>
          následník</emphasis>,
        </member>
        <member> </member>
      </simplelist>
    </para>
    <para>
        kde <emphasis>lk</emphasis> je levý a <emphasis>pk</emphasis> pravý kontext. Obecnější třídu tvoří (k,l)-systémy, kde levý kontext tvoří slovo o délce <emphasis>k</emphasis> modulů a pravý kontext slovo o délce <emphasis>l</emphasis> modulů. V některé litaratuře bývají označovány jako IL-systémy. V této práci se zabývám jejich podmnožinou, třídou 2L-systémů. Přepisovací pravidla v tomto případě zjišťují levý i pravý kontext s maximální délkou 1. Touto třídou lze pokrýt všechny požadované vlastnosti L-systémů na komunikaci modulů mezi sebou i s okolím. Pravidla 2L-systémů se zapisují v následující podobě:
    </para>
    <para>
      <simplelist type="vert" columns="1">
        <member> </member>
        <member>
          <emphasis>lk &lt; předchůdce > pk</emphasis>
        <inlineequation>
          <alt role="tex">\to</alt>
          <graphic fileref="math020402.png"/>
        </inlineequation> 
        <emphasis>následník</emphasis>.
        </member>
        <member> </member>
      </simplelist>
    </para>
    <para>
      U bezzávorkových L-systémů je proces zjišťování, zda přepisovací pravidlo odpovídá kontextu předchůdce, triviální a jednoznačný. Pro závorkové systémy se však literatura rozchází a jsou použity rozdílné podmínky. Jde především o zpracování pravého kontextu. Pro tuto práci jsem se rozhodl použít způsob, jež obdobně používá ve své práci James Scott Hannan <citation>Hanan92</citation>. Na rozdíl od jiných přístupů respektuje topologickou strukturu rostliny. Pokud totiž algoritmus například při zpracování pravého kontextu narazí na větvení, porovnává s pravým kontextem každou větev. U jiných přístupů se někdy porovnává pouze větev, která s předchůdcem sousedí v řetězci. Příklad je zobrazen na obrázku <xref linkend="pic02040201"/>.
    </para>
    <sect2 id="sec020401"> 
      <title>Párování levého kontextu</title>
      <para>
          Při párování levého kontextu dochází k porovnání modulů kontextu s moduly, které jsou v řetězci slova umístěny nalevo od modulu předchůdce. V topologii rostlinného organismu se tedy jedná o části rostliny, jež leží na nejkratší cestě ke kořenům. Pro každý modul existuje pouze jedna taková cesta a párování se tedy provádí pouze s jedním řetězcem modulů. Tato cesta, jež je v topologii spojitá, nemusí v řetězci slova tvořit spojitý řetězec modulů. Pokud je při tomto párování nalezen modul <envar>]</envar>, znamená to , že zde končí vedlejší větev. Ta však topologicky nenavazuje a musí být přeskočena. Párování tedy pokračuje za odpovídajícím symbolem <envar><alt role="tex">[</alt></envar>. Obrázek <xref linkend="pic02040101"/> ukazuje, jakým způsobem se levý kontext páruje. Modul <emphasis>A</emphasis> je zde levým kontextem pro předchůdce <emphasis>B</emphasis> i <emphasis>C</emphasis>. Modul <emphasis>B</emphasis> však není předchůdcem <emphasis>C</emphasis>, neboť spolu topologicky nijak nesousedí.      
        </para>
        <figure float="1" id="pic02040101">
          <title>Párování levého kontextu.</title>
    	  	<mediaobject>
            <imageobject>
    			    <imagedata fileref="02040101.jpg" format="JPG"/>
    	      </imageobject>
          </mediaobject>
    	  </figure>
      </sect2>
      <sect2 id="sec020402"> 
        <title>Párování pravého kontextu</title>
        <para>
          Párování pravého kontextu porovnává moduly napravo od předchůdce. Jde tedy o moduly, jež vyrůstají z předchůdce. Situace je zde komplikovanější, neboť je někdy zapotřebí kvůli větvení provést párování na více řetězcích. Pokud totiž za předchůdcem následuje rozvětvení symbolizované modulem <envar>[</envar>, je nutné provést párování s hlavní větví a se všemi vedlejšími větvemi. Pokud alespoň v jednom případě dojde ke shodě, je pravidlo považováno za odpovídající danému modulu předchůdce. Na obrázku <xref linkend="pic02040201"/> je znázoněno jednoduché větvení, kdy ke shodě dochází v případě, že pravý kontext bude modul <emphasis>B</emphasis> nebo <emphasis>C</emphasis>.  
        </para>
        <figure float="1" id="pic02040201">
          <title>Párování pravého kontextu.</title>
    	  	<mediaobject>
            <imageobject>
    			    <imagedata fileref="02040201.jpg" format="JPG"/>
    	      </imageobject>
          </mediaobject>
    	  </figure>
      </sect2>
  </sect1>
  <sect1 id="sec0205">
    <title>Parametrické L-systémy</title>
    <para>
      Přestože doposud popisované typy L-systémů poskytují širokou škálu možností pro generování rostlin, jejich možnosti jsou v jistém směru omezené. Problém spočívá v tom, že veškeré moduly lze použít pouze v celočíselných násobcích. Výsledkem pak je, že nelze například vytvořit tak jednoduchý tvar, jako je rovnoramenný trojúhelník, jehož základna má v poměru k ramenům iracionální délku. Pro odbourání těchto problémů je nutné zavést parametrické L-systémy, jež pracují nad parametrickými slovy. Parametrická slova se skládají z modulů, které kromě znaku obsahují také přidružené parametry.   
    </para>
    <para>
      Identifikující znak 
      <inlineequation>
        <alt role="tex">A</alt>
      </inlineequation> 
      náleží do abecedy 
      <inlineequation>
        <alt role="tex">V</alt>
      </inlineequation>
       a parametry 
      <inlineequation>
        <alt role="tex">a_1 , a_2 ,…, a_n</alt>
      </inlineequation>
      náleží do množiny 
      <inlineequation>
        <alt role="tex">\Re</alt>
      </inlineequation>. Takovýto rozšířený modul se značí jako 
      <inlineequation>
        <alt role="tex">A( a_1 , a_2 ,..., a_n )</alt>
      </inlineequation> a patří do množiny 
      <inlineequation>
        <alt role="tex">M = V\times \Re^*</alt>
      </inlineequation>,
      kde 
      <inlineequation>
        <alt role="tex">\Re^*</alt>
      </inlineequation> je množina všech konečných posloupností parametrů. 
    </para>
    <para>
      Pravidla parametrických 0L-systémů mají tvar 
    </para>
    <para>
      <simplelist type="vert" columns="1">
        <member> </member>
        <member>
          <emphasis>předchůdce (parametry) : podmínka 
          <inlineequation>
            <alt role="tex">\to</alt>
          </inlineequation> 
          následník
          </emphasis>.
        </member>
        <member> </member>
      </simplelist>
     </para>
     <para> 
       Parametry modulů následníka nemusí mít nutně tvar reálného čísla. Typicky jde o aritmetické výrazy, které se před každým derivačním krokem vyhodnotí na základě hodnot formálních parametrů předchůdce. Tyto parametry jsou označovány jako <emphasis>Σ</emphasis> a aritmetické výrazy, jež tyto parametry používají <emphasis>E(Σ)</emphasis>. Dalším rozšířením parametrických systémů  je podmínka. Přepisovací pravidlo může být použito pro přepis pouze tehdy, pokud je podmínka splněna. Jedná se o logický výraz označovaný jako <emphasis>C(Σ)</emphasis>. Podmínka je volitelný parametr pravidla a pokud není definována, je implicitně považována za splněnou. I pro vyhodnocení podmínky se používají parametry předchůdce. Jak výrazy v podmínce tak výrazy v následníkovi jsou složeny z různých aritmetických znamének, volání funkcí, konstant a formálních parametrů předchůdce. 
    </para>
    <para>
      Parametrické 0L-systémy <citation>Prusin04</citation> jsou definovány jako uspořádaná čtveřice 
      <inlineequation>
        <alt role="tex">G= \langle V, \Sigma, \omega, P \rangle</alt>
      </inlineequation>, kde 
      <itemizedlist mark='opencircle'>
        <listitem>
          <para>
            <emphasis>V</emphasis> je konečná neprázdná <emphasis>abeceda</emphasis>,
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>Σ</emphasis> je množina <emphasis>formálních parametrů</emphasis>,
          </para>
        </listitem>
        <listitem>
          <para>
            <inlineequation>
              <alt role="tex">\omega \in ( V\times \Re )^+ </alt>
            </inlineequation> 
            je neprázdné parametrické počáteční slovo nazývané <emphasis>axiom</emphasis> a
          </para>
        </listitem>
        <listitem>
          <para>
            <inlineequation>
              <alt role="tex">P \subset ( V\times \Sigma^* )^+ \times C(\Sigma) \times (V \times E(\Sigma)^*)^*</alt>
            </inlineequation> 
            je konečná množina <emphasis>přepisovacích pravidel</emphasis>.
          </para>
        </listitem>
       </itemizedlist> 
    </para>
    <para>
      Ukázkou, jak je díky parametrům škála vytvářených slov rozšířena, je následující L-systém. Pomocí parametrů a různého nastavení konstant lze pomocí jediného pravidla vytvářet tvarově velice rozmanité struktury. Obrázek <xref linkend="pic020501"/> zobrazuje čtyři příklady nastavení L-systému dle <citation>Prusin96</citation>. Všechny tyto stromové struktury byly vytvořeny pomocí následujícího jednoduchého L-systému:      
    </para> 
    <para>
      <inlineequation>
        <alt role="tex">\omega : A(100, w_0 )</alt>
      </inlineequation>  
    </para>
    <para>
      <inlineequation>
        <alt role="tex">p_1 : A(s,w) : s>= min \to !(w)F(s)[+( \alpha_1 )/( \varphi_1 ) A ( s \star r_1 , (w \star q)^e ) ]
        [+( \alpha_2 )/( \varphi_2 ) A ( s \star r_2 , (w \star (1-q) )^e ) ]</alt>
      </inlineequation>  
    </para>
    <para>
      <figure float="1" id="pic020501">
        <title>Stromové struktury vytvořené pomocí parametrického L-systému.</title>
  	  	<mediaobject>
          <imageobject>
  			    <imagedata fileref="020501.jpg" format="JPG"/>
  	      </imageobject>
        </mediaobject>
  	  </figure>
    </para>
    <para>
			<table id="tab03040101" frame="topbot" tocentry="1" pgwide="1">
				<title>Hodnoty konstant pro vytvoření stromů z obrázku <xref linkend="pic020501"/>.</title>
					<tgroup cols="12" colsep="0" rowsep="0">
					<thead>
						<row>
							<entry colsep="1">Obrázek</entry>
							 <entry>
                <inlineequation>
                  <alt role="tex">r_1</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">r_2</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">\alpha_1</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">\alpha_2</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">\varphi_1</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">\varphi_2</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">w_0</alt>
                </inlineequation> 
              </entry>
              <entry>
              <inlineequation>
                <alt role="tex">q</alt>
              </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">e</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">min</alt>
                </inlineequation>
              </entry>
              <entry>
                <inlineequation>
                  <alt role="tex">n</alt>
                </inlineequation>
              </entry>
						</row>
					</thead>
					<tbody>
						<row rowsep="0">
							<entry colsep="1">a</entry>
							<entry colsep="0">.65</entry>
							<entry colsep="0">.71</entry>
							<entry colsep="0">27</entry>
							<entry colsep="0">-68</entry>
							<entry colsep="0">0</entry>
							<entry colsep="0">0</entry>
							<entry colsep="0">20</entry>
							<entry colsep="0">.53</entry>
							<entry colsep="0">.50</entry>
							<entry colsep="0">1.7</entry>
							<entry colsep="0">12</entry>
						</row>
						<row rowsep="0">
            	<entry colsep="1">b</entry>
            	<entry colsep="0">.92</entry>
							<entry colsep="0">.37</entry>
							<entry colsep="0">0</entry>
							<entry colsep="0">60</entry>
							<entry colsep="0">180</entry>
							<entry colsep="0">0</entry>
							<entry colsep="0">2</entry>
							<entry colsep="0">.50</entry>
							<entry colsep="0">.00</entry>
							<entry colsep="0">0.5</entry>
							<entry colsep="0">15</entry>
            </row>
						
						<row rowsep="0">
            	<entry colsep="1">c</entry>
            	<entry colsep="0">.80</entry>
							<entry colsep="0">.80</entry>
							<entry colsep="0">30</entry>
							<entry colsep="0">-30</entry>
							<entry colsep="0">137</entry>
							<entry colsep="0">137</entry>
							<entry colsep="0">30</entry>
							<entry colsep="0">.50</entry>
							<entry colsep="0">.50</entry>
							<entry colsep="0">0.0</entry>
							<entry colsep="0">10</entry>
            </row>
						<row rowsep="0">
            	<entry colsep="1">d</entry>
            	<entry colsep="0">.55</entry>
							<entry colsep="0">.95</entry>
							<entry colsep="0">-5</entry>
							<entry colsep="0">30</entry>
							<entry colsep="0">137</entry>
							<entry colsep="0">137</entry>
							<entry colsep="0">5</entry>
							<entry colsep="0">.40</entry>
							<entry colsep="0">.00</entry>
							<entry colsep="0">5.0</entry>
							<entry colsep="0">12</entry>
            </row>
					</tbody>
				</tgroup>
			</table>
		</para>
  </sect1>
  <sect1 id="sec0206">
    <title>Stochastické L-systémy</title>
    <para>
      Všechna slova generovaná stejným deterministickým L-systémem jsou identická. Tato předvídatelnost je samozřejmě jednou z velkých výhod modelování pomocí L-systémů. Díky ní může uživatel přímo pozorovat dopady provedených změn. Tento determinismus má však také za následek, že modely zcela neodpovídájí svým biologickým protějškům. V přírodě se totiž jedinci určitého rostlinného druhu často mezi sebou liší. Mohou se lišit stavbou i tvarem a přitom stále sdílet určité vlastnosti dané svým druhem. Pro simulaci tohoto jevu je dobré vnést do L-systému určitý druh náhodnosti, jež zároveň zajistí, že základní vlastnosti daného druhu budou zachovány a výslední jedinci se budou lišit jen ve vybraných detailech. Pro tento účel byly zavedeny stochastické L-systémy, které umožňují do přepisovacího procesu zavést náhodnost velice dobře kontrolovatelným způsobem.
    </para>  
    <para>
      <figure float="1" id="pic020601">
        <title>Příklady různých jedinců generovaných jedním stochastickým L-systémem.</title>
  	  	<mediaobject>
          <imageobject>
  			    <imagedata fileref="020601.jpg" format="JPG"/>
  	      </imageobject>
        </mediaobject>
  	  </figure>
    </para>
    <para>
      Takovýto parametrický stochastický 0L-systém lze definovat jako uspořádanou pětici
      <inlineequation>
        <alt role="tex">G_\pi = \langle V, \Sigma, \omega, P, \pi \rangle .</alt>
      </inlineequation>
      Definice abecedy <emphasis>V</emphasis>, formálních parametrů <emphasis>Σ</emphasis>, axiomu 
      <inlineequation>
        <alt role="tex">\omega</alt>
      </inlineequation>
      a množiny přepisovacích pravidel <emphasis>P</emphasis> je stejná jako u parametrických L-systémů. Navíc je zde definována funkce 
      <inlineequation>
        <alt role="tex">\pi</alt>
      </inlineequation>, která každému pravidlu z množiny <emphasis>P</emphasis> přiřazuje aritmetický výraz
      <inlineequation>
        <alt role="tex">E( \Sigma )</alt>
      </inlineequation>. 
      Tento výraz nabývá vždy nezáporných hodnot a jeho výsledek se označuje jako <emphasis>pravděpodobnostní faktor</emphasis> přepisovacího pravidla. Pokud je při přepisovacím procesu více pravidel, které odpovídají určitému modulu, použije se pro výběr pravidla vzorec, který na základě pravděpodobnostního faktoru určí pravděpodobnost použití pravidla. Tento faktor nenabývá obecně konstantních hodnot pro celý přepisovací proces, ale vyhodnocuje se, podobně jako podmínka a následník, na základě formálních parametrů předchůdce při každém použití pravidla. Pokud označíme 
      <inlineequation>
        <alt role="tex">\widehat{P} \subseteq P </alt>  
      </inlineequation>
      jako množinu všech odpovídajících pravidel jednomu modulu, pak pravděpodobnost 
      <inlineequation>
        <alt role="tex">prob(p_k)</alt> 
      </inlineequation> 
      jednoho pravidla 
      <inlineequation>
        <alt role="tex">p_k \in \widehat{P}</alt>
      </inlineequation>
      odpovídá výsledku rovnice 2.6.1.
    </para>
    <para>
    <equation>
       <title>Výpočet pravděpodobnosti výběru pravidla p<subscript>k</subscript></title>
       <mediaobject>
          <imageobject>
             <imagedata fileref="math020601.png"/>
          </imageobject>
          <textobject role="tex">
             <phrase>prob(p_k) = \frac {\pi ( p_k )}{ \sum_{ p_i \in \widehat{P} } \pi ( p_i )  }</phrase>    <!-- -->
          </textobject>
       </mediaobject>
    </equation>
    </para>
  </sect1>
</chapter>


<chapter id="ch03">
  <title>Modelování rostlinných organismů</title>
  <para>
    Efektivní a reálné zobrazování rostlin je v oblasti počítačové grafiky velice aktuální a diskutované téma. Hlavním důvodem je, že se jedná o zcela běžně zobrazované objekty v různých aplikacích, scénách a simulacích. Jejich generování a zobrazení však na rozdíl od jiných často zobrazovaných modelů není tak jednoduché. Většina modelů je totiž tvořena relativně velkými plochami a lze je vytvořit malým množstvím polygonů. Rostlinné organismy jsou však tvořeny složitými strukturami malých objektů, které jsou navíc řízené určitými přírodními zákonitostmi. Jejich modely jsou tedy díky velkému množství polygonů složitější pro vykreslování. Kvůli složité vnitřní struktuře je navíc komplikované i jejich generování. 
  </para>
  <para>
    Tato kapitola se zabývá samotnou problematikou vytváření modelů rostlin. Jsou zde vysvětleny metody, jež byly v této práci použity pro návrh a modelování rostlinných organismů při zachování některých nejdůležitějších přírodních pravidel.
  </para>
  <sect1 id="sec0301">
    <title>Interpretace želví grafikou</title>
    <para>
Protože byly L-systémy navrženy jako matematický model bez geometrické interpretace, je potřeba pro modelování rostlin použít některý z přístupů, jež pro tento účel byly buď vyvinuty nebo byly převzaty. Sám Lindenmayer publikoval v roce 1974 řešení jež nahrazovalo moduly řetězců grafickými obrazci. Šlo však hlavně o topologii větvení rostlin a detaily jako délky nebo úhly natočení segmentů byly do modelu dodávány dodatečně. Během sedmdesátých a osmdesátých let vzniklo ještě mnoho jiných interpretací L-systémů, jež například ukázaly, že L-systému jsou velmi platným nástrojem pro tvorbu fraktálů. V roce 1986 přišel Przemyslaw Prusinkiewicz s myšlenkou interpretovat L-systémy jako pohyb želvy známé z programovacího jazyka LOGO <citation>Abel82</citation>. Tato želva funguje jako kurzor, který přijímá různé příkazy týkající se jeho pohybu. Na základě těchto příkazů pak tento kurzor kreslí svým pohybem jednu spojitou čáru. Použití želví grafiky značně rozšiřuje geometrické možnosti L-systémů a je ideální pro tvorbu rostlinných struktur. 
    </para>
    <sect2 id="sec030101">
      <title>Planární želví grafika</title>
      <para>
        Jelikož původ želví grafiky spočívá v pohybu kurzoru po obrazovce, její původní koncept zahrnoval pohyb ve dvojrozměrném prostředí. Želva je definovaná jako trojice parametrů 
        <inlineequation>
          <alt role="tex">(x,y, \alpha )</alt>
        </inlineequation>
        , kde 
        <inlineequation>
          <alt role="tex">x</alt>
        </inlineequation>
        a
        <inlineequation>
          <alt role="tex">y</alt>
        </inlineequation> 
        udávají kartézké souřadnice želvy a úhel 
        <inlineequation>
          <alt role="tex">\alpha</alt>
        </inlineequation>
        směr, kterým želva míří. Jde o tzv. čelo želvy. Pokud zavedeme navíc hodnotu pro délku kroku a výchozí přírůstek úhlu, o který se želva bude otáčet, můžeme vytvořit jednoduchá pravidla pro pohyb želvy v rovině. Jednotlivé znaky pak reprezentují daný modul a také akci, která je při načtení tohoto modulu provedena.
      </para>
      <para>
        <variablelist>
    			<varlistentry>
    				<term>F</term>
    				<listitem>
    					<para>Želva provede krok vpřed o předem definované délce na pozici 
              <inlineequation>
                <alt role="tex">(x',y')</alt>
              </inlineequation>
              . Mezi body 
              <inlineequation>
                <alt role="tex">(x,y)</alt>
              </inlineequation>
              a
              <inlineequation>
                <alt role="tex">(x',y')</alt>
              </inlineequation> 
              je vykreslena úsečka.</para>
    				</listitem>
    			</varlistentry>
          <varlistentry>
    				<term>+</term>
    				<listitem>
    					<para>Přikáže želvě otočit se o předem definovaný přírůstek úhlu doleva. Úhel želvy se zvětší o tuto hodnotu.</para>
    				</listitem>
    			</varlistentry>
          <varlistentry>
    				<term>-</term>
    				<listitem>
    					<para>Přikáže želvě otočit se o předem definovaný přírůstek úhlu doprava. Úhel želvy se zmenší o tuto hodnotu.</para>
    				</listitem>
    			</varlistentry>
        </variablelist>
      </para>
      <para>
        Vykreslování pomocí želví grafiky probíhá tak, že želva s počátečními parametry 
        <inlineequation>
          <alt role="tex">( x_0 , y_0 , \alpha_0 )</alt>
        </inlineequation> 
        interpretuje jednotlivé znaky řetězce postupně zleva doprava.
      </para>
    </sect2>
    <sect2 id="sec030102">
      <title>Interpretace závorkových L-systémů</title>
      <para>
        Jak již bylo výše zmíněno, pro simulaci větvících se struktur rostlin je nutné rozšíření L-systémů o závorky. Každý podřetězec uzavřený závorkami zleva i zprava představuje v topologii rostliny jednu větev. Při použití želví grafiky je tak nutné v bodech větvení rozdělit souvislou čáru, jež želva kreslí, na minimálně dvě nové cesty. Pro tyto účely se užívá zásobníku. Pokud želva narazí při procházení slova na znak <envar>[</envar>, uloží se spolu se svými parametry na zásobník a její kopie pokračuje v interpretaci řetězce za závorkou. Naopak pokud želva narazí na znak <envar>]</envar>, je odstraněna a v interpretaci pokračuje želva z vrcholu zásobníku.  
      </para>
    </sect2>
    <sect2 id="sec030103">
      <title>Rozšíření pro interpretaci L-systémů v 3D</title>
      <para>
        Jednou z hlavních výhod želví grafiky je její jednoduchá rozšiřitelnost pro použítí ve třech rozměrech. Parametry želvy však musejí být rozšířeny. Pro pozici želvy je zaveden vektor 
        <inlineequation>
          <alt role="tex">\vec{P}</alt>
        </inlineequation>. 
        Orientaci určují tři jednotkové vektory 
        <inlineequation>
          <alt role="tex">\vec{H}</alt>
        </inlineequation>,
        <inlineequation>
          <alt role="tex">\vec{L}</alt>
        </inlineequation> a
        <inlineequation>
          <alt role="tex">\vec{U}</alt>
        </inlineequation>
        takové, že splňují rovnici 
        <inlineequation>
          <alt role="tex">\vec{H} \times \vec{L} = \vec{U}</alt>
        </inlineequation>. Vektor 
        <inlineequation>
          <alt role="tex">\vec{H}</alt>
        </inlineequation>, podobně jako u rovinné želvy, udává kam želva směřuje. Vektor 
        <inlineequation>
          <alt role="tex">\vec{U}</alt>
        </inlineequation>
        směřuje směrem nahoru a vektor 
        <inlineequation>
          <alt role="tex">\vec{L}</alt>
        </inlineequation>
        směřuje vlevo od želvy.
      </para>
      <para>
  		  <figure float="1" id="pic03010301">
          <title>Polohové a pohybové parametry želvy v 3D prostoru.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="03010301.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>
      </para>
      <para>
        Sada příkazů je v 3D také značně rozšířena. Pro změnu orientace želva interpretuje příkazy, jež želvu rotují okolo jednotlivých os. Pro tyto rotace jsou běžně používány termíny z letectví: kurs, podélný sklon a příčný náklon. Kompletní sada příkazů, kterou interpretuje i zásuvný modul, jež byl vytvořen v rámci této práce, je i spolu s popisem interpretovaných funkcí uvedena v příloze <xref linkend="appA"/>.  
      </para>    
    </sect2>    
  </sect1>
  <sect1 id="sec0302">
    <title>Subapikální L-systémy</title>
    <para>
      Závorkové L-systémy umožnují vytvářet velice širokou škálu řetězců. Ne všechny však odpovídají rostlinné stavbě a pro generování rostlin se tak nehodí. Zavádějí se proto jistá omezení a pravidla, obvykle nazýváné jako vzory větvení, jež nám zaručí respektování některých přírodních vlastností. Výsledkem pak jsou L-systémy, které pravdivěji odpovídají reálným rostlinám. Jednou z těchto podmnožin jsou i subapikální L-systémy. Poprvé byly představeny Alicí Kelemenovou v roce 1986 <citation>Kele86</citation>. Myšlenkou těchto L-systémů je, že k větvení dochází pouze u vrcholů již exitujících větví. Tato vlastnost výchází ze základních výsledků při pozorování rostoucích rostlin. Nové rostlinné orgány, jako je stonek, větve, listy nebo květy mohou být vytvořeny pouze z <emphasis>apikálního meristému</emphasis>. Tato tkáň obsahuje aktivně se dělicí buňky a nachází se v oblasti vrcholů větví.
    </para>
    <para>
		  <figure float="1" id="pic030201">
        <title>První řada (a) zobrazuje vývoj struktury, jež splňuje podmínku subapikálního větvení. Druhá větvená struktura (b) ji nesplňuje<citation>Prusin94</citation>.</title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="030201.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>
    </para>
  </sect1>
  <sect1 id="sec0303">
    <title>Vzory větvených struktur</title>
    <para>
      Jedním z nejvýznamnějších parametrů rostlin je způsob větvení. Má totiž velice zásadní vliv na vzhled. Zařazením rostliny do některého z typů větvení lze také někdy odvodit typ L-systému, který bude nutné pro vygenerování modelu použít. Tato kapitola obsahuje základní vzory větvení rostlin, jež se v přírodě vyskytují.
    </para>
    <sect2 id="sec030301">
      <title>Monopodiální vzor</title>
      <para>
        Monopodiální struktury se vyznačují jedním hlavním souvislým stonkem. Z něj pak vychází mnoho vedlejších větví. Jelikož hlavní kmen je vždy nejstarší větví, jeho tloušťka je největší. Vedlejší větve se pak vyvíjejí podle stejného vzoru. Tento vzor lze dále rozdělit podle distribuce vedlejších větví na hlavním stonku.
      </para>
      <para>
  		  <figure float="1" id="pic03030101">
          <title>Ukázky monopodiálního větvení stromů <citation>Prusin04</citation>.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="03030101.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>
      </para>
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <para>
              <emphasis>Bazitonické struktury</emphasis> mají větve u vrcholu rostliny méně vyvinuté, než větve blíže základny rostliny. Lze je vytvořit i za pomocí jednoduchých D0L-systémů. Pokud je totiž při přepisování dodržena subapikální podmínka a je postupováno tak, že moduly vrcholu jsou přepisovány určitým počtem meziuzlů zakončených opět vrcholy, je zřejmé, že větve blíže kořenů budou rozvinutější. Je na nich totiž provedeno větší množství iterací. V přírodě se jedná o jednodušší organismy. Typickými zástupci jsou například jehličnany nebo cykasy.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis>Mezotonický a akrotonický typ větvení</emphasis> lze v přírodě také nalézt. U takto stavěných rostlin jsou nejrozvinutější větve uprostřed, respektive u vrcholu stonku. Pro větvení dále od počátku větve je však zapotřebí zavést do L-systému signály nebo růstový potenciál. Tyto mechanismy však nelze vytvořit pomocí D0L-systémů. Propagaci signálu lze provést pomocí kontextu u kontextových L-systémů. Zvyšování růstového potenciálu lze provést naopak pomocí parametrických L-systémů. 
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
  		  <figure float="1" id="pic03030102">
          <title>Bazitonické (a), mezotonické (b) a akrotonické (c) dělení <citation>Prusin94</citation>.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="03030102.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>
      </para>
    </sect2>
    <sect2 id="sec030302">
      <title>Sympodiální vzor</title>
      <para>
        Jedná se o vývojově pokročilejší typ větvení. Hlavní stonek je nesouvislý a jeho růst je brzy potlačen. Vedlejších větví je zde menší počet. Jsou však o to více rozvinutější. Většina listnatých stromů tvoří právě sympodiální struktury. Modely s touto strukturou lze vytvořit i za pomocí D0L-systémů. Docílíme však pouze jednoduše se dělících a opakujících se topologií. Pro pokročilejší modely je možné použít i jiné typy L-systémů.
      </para>
      <para>
		  <figure float="1" id="pic03030201">
        <title>Ukázky sympodiálního větvení stromů <citation>Prusin04</citation>.</title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="03030201.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>
    </para>
    </sect2>
  </sect1>  
  <sect1 id="sec0304">
    <title>Vlastnosti větvených struktur rostlinných organismů</title>
    <para>
      Ačkoli se větvení stromů i jiných rostlin může jevit náhodné, platí i pro ně určitá pravidla. Již Leonardo da Vinci zkoumal některé zákonitosti větvení stromů a stanovil postulát. Ten říká, že obsah průřezu větve před větvením je shodný se součtem všech obsahů průřezů větví za větvením. Později se ukázalo, že tento odhad byl velice přesný a je vhodné jej při návrhu L-systému dodržovat.
    </para>
    <para>
		  <figure float="1" id="pic030401">
        <title>Distribuce cév ve větvích a závíslost množství cév na úhlu dělení.</title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="030401.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>
    </para>
    <para>
      V roce 1994 tento postulát rozšířil Matthew Holton <citation>Holt94</citation>. Na rozdíl od da Vinciho však již znal vnitřní strukturu větví a také princip cévních svazků u cévnatých rostlin. Cévní svazky jsou součástí transportního systému rostlin a rozvádějí živiny z kořenů rostliny do jejího těla. Při větvení dochází k rozdělení svazku na dva či více samostaných svazků. Toto rozdělení právě souvisí s da Vinciho postulátem. Kvůli menšímu množství živin, mají rozvětvené větve adekvátně menší obsah průřezu. Holton však navíc při modelování svých rostlin použil zajímavou spojitost množství cévních svazků a úhlu dělení větví. Cévní svazky totiž plní také zpevňovací funkci. Zavedl vztah, podle něhož lze množství cév, a tedy i tloušťku větve při dělení, určit podle úhlu odchylky od původní osy. Čím je tento úhel větší, tím menší je počet cév a průměr větve.
    </para>
  </sect1>
</chapter>

<chapter id="ch04">
  <title>Zásuvný modul LSystem</title>
  <para>
    Stěžejní částí této diplomové práce je návrh a implementace zásuvného modulu pro systém Vrecko. Tento modul umožňuje simulaci rostlin, stromů a jiných modelů pomocí různých typů L-systémů a jejich následnou grafickou interpretaci a zobrazení v systému Vrecko. Návrh a analýza byla provedena s velkým důrazem na modularitu a tedy možnost pozdějšího rozšíření o nové funkce.
  </para>
  <para>
    Logicky lze zásuvný modul LSystem rozdělit na tři části. První celek tvoří syntaktický analyzátor souborů L-systémů a generátor slov. Syntaktický analyzátor zajišťuje správné zpracování L-systémů, jejich náhrání ze souboru a načtení všech potřebných parametrů. Následně pak zpracuje načtená data, která generátor použije pro provedení jednotlivých iteračních kroků L-systémů. Slova i ostatní data jsou během iteračního procesu uložena do datových struktur optimalizovaných pro daný účel. Jelikož existuje několik typů L-systémů, je implementována funckionalita, která pro přepisování vybere algoritmus, který je svými schopnostmi i časovou náročností nejvhodnější pro zpracovávaný L-systém. Tvorba L-systémů se složitější strukturou se většinou neobejde bez hiearchického rozdělení problému. Zásuvný modul proto umožňuje rozdělit model na několik úrovní a do hlavního L-systému vkládat podsystémy. V praxi to pak například u generování stromů znamená, že je možné vytvořit rozdílné L-systémy pro listy, květy a plody, které lze následně vložit do L-systému kostry stromu.
  </para>
  <para>
    Druhý celek se zabývá grafickou interpretací vygenerovaného řetězce. S dříve zmiňovaným celkem komunikuje pouze na úrovni předání vygenerovaného slova, poskytnutí detailních parametrů pro nastavení interpretu a také mechanismu pro zpracování dotazů. Interpret v současné podobě používá pro generování geometrie modelů výhradně želví grafiku. Tento modul však obsahuje rovněž interpret, jenž k vytváření geometrie neslouží. Jedná se o interpret pro zpracování dotazů během generování iterací L-systémů. Je tedy určen pro rychlé zjištění polohy a orientace želvy. Pro zpracování slov obsahující závorky má interpret implementován zásobník. Uživatel má také možnost volit z několika typů želv, které mu dovolují vykreslovat geometrii rozdílnými přístupy. Poslední ze tří celků plní funkci řídícího modulu a je umístněn nad oběma předcházejícími celky, jež spravuje. Zároveň sprostředkovává komunikaci jak se systémem Vrecko tak mezi moduly navzájem. Jedná se především o načtení základních parametrů, které oba moduly potřebují pro svou inicializaci. 
  </para>
  <sect1 id="sec0401">
    <title>Vývoj zásuvného modulu</title>
    <para>
      Vývoj probíhal na platformě Windows v prostředí Visual Studio 2005 v jazyce C++. Veškeré třídy náleží do jmenného prostoru <envar>AP_LSystem</envar>. Stejně jako celý systém Vrecko je i modul LSystem postaven na OpenSceneGraphu. Zejména se jedná o část zajišťující interpretaci L-systémů a generování geometrie. Mimo to byly pro vývoj použity některé z knihoven Boost. Knihovna boost::program_options umožňuje jednoduché a intuitivní ukládání a zpracovávání nastavení a konfiguračních souborů. Knihovna boost::lexical_cast jednoduše převádí a přetypovává řetězce znaků. Z balíku Boost je také použit inteligentní ukazatel boost::shared_ptr. O zpracování XML souborů se stará knihovna Xerces-C.
    </para>
  </sect1>
  
  <sect1 id="sec0402">
    <title>OpenSceneGraph</title>
    <para>
      Základním kamenem pro modul LSystem i pro systém Vrecko je OpenSceneGraph API. Jedná se o objektově orientované rozhraní nad OpenGL. Nízkoúrovňová funkcionalita je zde převedena na objekty v grafech scén. Zároveň jsou možnosti OpenSceneGraphu oproti klasickému OpenGL značně rozšířené a je přidáno mnoho funkcionalit, jež zjednodušují a urychlují vývoj. 
    </para>
  </sect1>
  <sect1 id="sec0403">
    <title>Vrecko</title>
    <para>
      Jak již bylo zmíněno, je modul LSystem určen pro systém Vrecko. Jedná se o prostředí pro tvorbu virtuální reality vyvíjené v rámci HCI laboratoře na Fakultě informatiky Masarykovy univerzity v Brně. Slouží primárně pro vytváření scén, jež nějakým způsobem demonstrují a zkoumají možnosti interakce člověka s počítačem. Vychází z principu OpenSceneGraph a scény jsou tedy obdobně definovány jako grafy. Scény se v tomto prostředí dělí na objekty, které mají určité vlastnosti a dovednosti. Díky ním lze objekty ovládat a měnit jejich tvar i vlastnosti. Zároveň lze k tomuto systému připojit řadu různých zařízení pro interakci uživatele s obsahem scény. 
    </para>
  </sect1>
</chapter>
<chapter id="ch05">
  <title>Generování slov pro modely rostlin</title>
  <para>
    Tato kapitola se zabývá implementací syntaktického analyzátoru a následným generováním slov pomocí L-systémů. Při implementaci této části byl kladen velký důraz na rychlost a také na modularitu. Rychlost je zde důležitá zejména při iteračním procesu, neboť výsledné slovo může mít délku až v řádu statisíců modulů. Je tedy třeba zajistit vhodné struktury pro ukládání dat a vybrat vhodný algoritmus pro rychlý přepis pravidel. Modularita a rozšiřitelnost zde s rychlostí úzce souvisí. Jednotlivé typy L-systémy totiž vyžadují rozdílné přístupy při přepisování pravidel a tak je důležité vytvořit více algoritmů, jež budou různé typy jednodušších i komplexnějších L-systémů zpracovávat. Zároveň je však třeba zaručit, aby jednodušší L-systémy nebyly zpracovány příliš složitými algoritmy, ale aby byly vybrány jednodušší a hlavně optimalizovanější postupy pro daný problém. Modularita je zde důležitá i pro syntaktický analyzátor, který tak zvládne zpracovat více formátů L-systémů.
  </para>
  <para>
    Celou tuto funkcionalitu a komunikaci s okolím zajišťuje třída <envar>LSystemGenerator</envar>. Tato třída je potomkem třídy <envar>AbstractGenerator</envar>, která obsahuje rozhraní pro obsluhu této třídy. Instance třídy <envar>LSystemGenerator</envar> obsahuje odkaz na hlavní L-systém třídy <envar>AbstractLSystem</envar>, který je poté použit pro generování slova. Hlavním úkolem třídy <envar>LSystemGenerator</envar> je vybrat správný syntaktický analyzátor pro nahrání souboru s L-systémem a na základě získaných parametrů vybrat a vytvořit instanci třídy dědící z <envar>AbstractLSystem</envar>, jež bude pro následný iterační proces nejvhodnější. Nahráním souborů a jejich strukturou se zabývá následující kapitola.
  </para>
  <sect1 id="sec0501">
    <title>Soubory L-systémů</title>
    <para>
      Vstupním bodem pro každý L-systém je jeho definice uložená v jednom z podporovaných souborových formátů. Spolu s definicí může být součástí celá řada parametrů, které mohou ovlivnit jak proces přepisování pravidel tak i způsob následné geometrické interpretace. Zásuvný modul nyní podporuje dva typy souborů a lze jej rozšířit o podporu dalších formátů. Jedná se o textový formát LS, jenž v obdobné formě používá ve svých projektech výzkumná skupina Biologického Modelování a Vizualizace kolem prof. Przemyslawa Prusinkiewicze z University of Calgary. Tento formát byl zvolen z důvodu vedoucí úlohy této skupiny v oboru L-systémů. Druhým formátem je soubor napsaný ve značkovacím jazyce XML, jenž byl zvolen pro svou jednoduchou rozšiřitelnost a přehlednost.
    </para>
    <para>
      Struktura je v obou případech hierarchická a popis jejich entit je následující:  
      <itemizedlist mark='opencircle'>
        <listitem>
          <simpara><emphasis role="bold">Unikátní identifikátor L-systému</emphasis> je nutné přiřadit každému L-systému. Ten se pak používá hlavně při vkládání podřízených L-systémů nebo pro získávání parametrů o daném L-systému.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Typ L-systému</emphasis> je důležitým a nutným parametrem L-systému. Určuje například, zda je L-systém deterministický či bezkontextový. Na jeho správném nastavení pak závisí výběr správného algoritmu pro zpracování samotných pravidel a pro následný iterační proces.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Parametry</emphasis> nastavené přímo v souboru L-systému jsou specifické pro konkrétní L-systém. Pokud některé z parametrů nejsou nastaveny zde, použijí se pro generování a interpretaci slova globální parametry získané z konfiguračního souboru. Kompletní popis jednotlivých parametrů se nachází v příloze <xref linkend="appB"/>.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Podřízené L-systémy</emphasis> lze vkládát do každého L-systému. Lze je vložit přidáním cesty k souboru L-systému. Nikdy však není vhodné tvořit v grafu hierarchie L-systémů kružnice. Podrobněji se touto tématikou zabývá kapitola <xref linkend="sec0507"/>.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Axiom</emphasis> je počáteční řetězec symbolů. Jde tedy o slovo v nulté iteraci L-systému.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Přepisovací pravidla</emphasis> tvoří množinu pravidel, která budou použita při iteračním procesu. Na pořadí není brán zřetel, protože se při každém iteračním kroku aplikují všechna pravidla najednou. Z tohoto důvodu je důležité, aby byla jednotlivá pravidla jednoznačná a neexistovala dvě pravidla pro stejný modul předchůdce. Jedinou výjimkou jsou stochastické systémy. Struktura pravidel je závislá na jejich typu a podrobněji je popsána v odpovídajících podkapitolách kapitoly <xref linkend="sec0505"/>.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Homomorfismy</emphasis> jsou zvláštním typem přepisovacích pravidel, která se nezpracovávají během iteračního procesu. K přepisu těchto pravidel dochází vždy až po dokončení všech iterací.
          </simpara>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Formáty se implementují jako potomci třídy <envar>AbstractFile</envar>. Ta poskytuje rozhraní pro získání potřebných dat ze souboru.   
    </para>
    <para>
        <programlisting><![CDATA[
class AbstractFile
{
protected:
    unsigned m_Type;
    std::string m_Name, m_Axiom;
    std::vector<std::string> m_Rules, m_Homomorphisms, m_Subsytems;
    void substitute(std::map<std::string, std::string> &)
public:
    AbstractFile();
    virtual void open( std::string & ) = 0;
    std::vector<string> * getHomomorphisms();
    std::vector<string> * getRules();
    std::vector<string> * getSubsystems();
    std::string & getAxiom();
    unsigned getType();
    std::string & getName();
};
  			]]></programlisting>
    </para>
    <para>
      Třídy odvozené od třídy <envar>AbstractFile</envar> musí implementovat metodu <envar>open()</envar>, jež zaručí zpracování dat ze souboru a uloží je do jednotlivých atributů této třídy. Pomocná metoda <envar>substitute()</envar> nahrazuje řetězce a může být použita pro zpracování konstant nebo podřízených L-systémů. Ostatní metody slouží jen jako přístupové metody k atributům. 
    </para>
    <sect2 id="sec050101">
      <title>Formát LS</title>
      <para>
        Jedná se o jednoduchý textový formát založený na příkazech podobných preprocesorovým příkazům jazyka C. Některé příkazy jsou párové a musí být ukončeny. Jako hodnota je brán řetězec následující po příkazu. Tento řetězec nemůže obsahovat žádné bílé znaky. Formát <emphasis>LS</emphasis> dovoluje také vkládat komentáře použitím dvojitého lomítka <envar>//</envar>.  
      </para>
      <para>
        <programlisting><![CDATA[
#lsystem TernaryTree          // unikátní ID L-systému

#type 0L                      // typ L-systému
#define Pitch 65              // konstanta
#include data\ls\leaf.ls      // cesta k]]>&nbsp;<![CDATA[podřízenému L-systému

// parametry
#set Iteration=14             
#set TurtleType=STRAIGHT_PIPE
#set DefaultAngle=30.0

// axiom
#axiom
F'(0.65)A
#endaxiom

// přepisovací pravidla
#rules 
A:*->!(0.577)'(0.87)[/(90.74)B][/(-132.63)B]B
B:*->^(33.95)[^(Pitch)#{Leaf}][#{Leaf}]Z[^(Pitch)#{Leaf}][#{Leaf}]ZA
#endrules

#endlsystem
     ]]></programlisting>
      </para>
    </sect2>
    
    <sect2 id="sec050102">
      <title>Formát XML</title>
      <para>
        V případě <emphasis>XML</emphasis> souboru jde o klasický <emphasis>XML</emphasis> dokument verze 1.0 s kódováním UTF-8. Veškeré použité elementy jsou párové a nejsou použity žádné atributy. <envar>LSystem</envar> je kořenová značka, která obsahuje všechny potřebné entity. V následujícím odstavci je příklad zápisu L-systému do <emphasis>XML</emphasis> souboru.  
      </para>
      <para>
        <programlisting><![CDATA[
<?xml version="1.0"?>
<!-- kořenová značka -->
<LSystem>
  <!-- unikátní identifikátor L-systému -->
  <Name>TernaryTree</Name>
  <!-- typ L-systému -->
  <Types>
    <Type>0L</Type>
  </Types>
  <!-- konstanty -->
  <Constants>
    <LeafPitch>65.0</LeafPitch>
  </Constants>
  <!-- parametry -->
  <Parameters>
    <Iteration>14</Iteration>
    <TurtleType>STRAIGHT_PIPE</TurtleType>
    <DefaultAngle>30.0</DefaultAngle>
  </Parameters>
  <!-- subsystémy -->
  <Subsystems>
    <Subsystem>data\ls\leaf01.ls</Subsystem>
  </Subsystems>
  <!-- axiom -->
  <Axiom>F'(0.65)A</Axiom>
  <!-- přepisovací pravidla -->
  <Rules>
    <Rule>A:*->!(0.577)'(0.87)[/(90.74)B][/(-132.63)B]B</Rule>
    <Rule>B:*->^(33.95)[^(LeafPitch)#{Leaf01}][#{Leaf01}]Z
                       [^(LeafPitch)#{Leaf01}][#{Leaf01}]ZA</Rule>
  </Rules>
  <!-- homomorfismy -->
  <Homomorphisms>
    <Homomorphism>A:*->Z</Homomorphism>
  </Homomorphisms>
</LSystem>
			]]></programlisting>
      </para>
      <para>
        Některé symboly pravidel jsou bohužel zároveň řídícími symboly XML, a tak je zapotřebí nahradit je odpovídajícími XML entitami.
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0502">
    <title>Řetězce modulů</title>
    <para>
      Při generování slova L-systémem dochází k vytváření velmi dlouhých řetězců s nestejnorodými daty. Moduly, ze kterých se řetězce tvoří, totiž kromě znaku pro identifikaci modulu obsahují také parametry různých datových formátů. Zpracování takovýchto dat musí být navíc dostatečně rychlé. Pro tento účel byla vytvořena na míru přizpůsobená třída <envar>LongString</envar>. Data jsou zde uložena ve formátu, který umožňuje rychlou manipulaci s daty, především pak připojení nového řetězce na konec stávajícího. Při iteračním procesu je zapotřebí provádět tuto operaci rychle. S každou iterací je zpracováno původní slovo a podle něj se vytváří vytváří, na základě přepisovacích pravidel, nové slovo další iterace. Provádí to tak, že prohlíží jednotlivé moduly původního slova zleva doprava a hledá shodu s některým z předchůdců v přepisovacích pravidlech. V případě nalezení pravidla je následník přidán na konec nového slova. V případě, že předchůdce mezi pravidly nalezen není, připojí se na konec kopie původního modulu. Použije se tedy pravidlo identity. Implementací samotného přepisovacího mechanismu se zabývá kapitola <xref linkend="sec050403"/>  
    </para>
    <sect2 id="sec050201">
      <title>Vnitřní struktura řetězce</title> 
      <para>
        Datová struktura <envar>LongString</envar> je v jádru tvořena bajtovým polem. Toto pole se nezvětšuje při každém rozšíření řetězce, ale vždy jen po dosažení určité velikosti. Dochází tak ke znatelné úspoře času při alokaci paměti, která se provádí podstatně méně častěji. Každý modul je zde uložen jako znak identifikující daný modul a případně jeho parametry. Parametry mohou být typu <envar>int</envar>, <envar>unsigned char</envar> nebo typu <envar>double</envar>. Implementace dalších typů je možná a jednoduchá. Pro současné použití však nebyly jiné typy zapotřebí. Obrázek <xref linkend="pic05020101"/> ukazuje, jakým způsobem je struktura navržena. 
      </para>
      <figure float="1" id="pic05020101">
        <title>Vnitřní uspořádání dat v řetězci typu <envar>LongString</envar></title>
  	  	<mediaobject>
          <imageobject>
  			    <imagedata fileref="05020101.jpg" format="JPG"/>
  	      </imageobject>
        </mediaobject>
  	  </figure>
      <para>
        Jedno políčko odpovídá jednomu bajtu. Každý modul obsahuje jeden znak, jenž jej identifikuje. Dále pak může obsahovat libovolný počet parametrů. Každý parametr je identifikován jedním bajtem zleva a jedním zprava. Při použití této datové struktury tedy není nutné provádět jakékoli převody mezi typy, jejichž hodnoty jsou tak rychle dostupné. Pro ilustraci byly na obrázku použity u jednoho modulu dva různé datové typy.
      </para>
    </sect2>
    <sect2 id="sec050202">
      <title>Inicializace</title>
      <para>
        Pro vytvoření instance slouží jediný konstruktor. Parametrem je velikost řetězce. Implicitní hodnota tohoto parametru je 1 048 576 bajtů. Právě hodnota tohoto parametru je také použita jako minimální přírůstek alokované paměti, pokud se stávající paměť naplní. Plnění daty lze provádět buď připojováním řetězců, jež je popsáno v následující kapitole, nebo konverzí klasického zápisu řetězce typu <envar>std::string</envar> do podoby řetězce <envar>LongString</envar>. K tomu slouží metoda <envar>convertFromString()</envar>. Této možnosti lze využít při načítání pravidel získaných ze souboru.
      </para>
      <para>
        Identifikující znaky modulů jsou v nezměněné podobě uloženy i v řetězci <envar>LongString</envar>. Hodnoty parametrů jsou však konvertovány do odpovídajícího typu. Pro rozlišení typů se používají různé závorky. Zatímco kulaté závorky indikují typ <envar>double</envar>, složené závorky indikují typ <envar>integer</envar>. Konvertované hodnoty jsou v řetězci z obou stran obaleny jednobajtovým identifikátorem. Hodnota tohoto idetifikátoru odpovídá pořadí ve výčtovém typu <envar>ParameterType</envar>.  
      </para>
    </sect2>
    <sect2 id="sec050203">
      <title>Připojování řetězců</title>
      <para>
        Jak již bylo výše zmíněno, je tato struktura optimalizována pro opakované zvětšování přidáváním řetězců na její konec. Při každém připojení se provádí kontrola, zda je alokované místo dostatečné pro připojení dalších dat. Pokud ne, volá se automaticky metoda <envar>resize()</envar>, jež alokuje novou paměť a zvětší tento řetězec o délku nastavenou při vytváření instance.
      </para>
      <para>
        Pro připojení dat je k dispozici několik metod. Jedná se o různé formy metody <envar>append()</envar>. Ta poskytuje díky šabloně možnost uložit libovolný, ve výčtu <envar>ParameterType</envar> definovaný, datový typ. Kromě toho je tato metoda přetížena kvůli specifickým způsobům připojení některých dat. Lze tak připojit jiný řetězec typu <envar>LongString</envar> nebo pole bajtů ve správném formátu.
      </para>
    </sect2>
    <sect2 id="sec050204">
      <title>Přístup k datům řetězce</title>
      <para>
        Přistupovat lze k datům jedním ze čtyř způsobů. 
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara>Operátor <envar>[]</envar> přímo poskytuje hodnotu bajtu na určité pozici řetězce. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Díky metodě <envar>getData()</envar> lze získat blok dat nebo celý řetězec bajtů. Hodí se především při provádění substitucí. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Nejpoužívanější možností je metoda <envar>getSymbol()</envar>, díky níž lze získat blok dat odpovídající jednomu modulu, neboli symbolu, na dané pozici. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Metody šablony <envar>getParameters()</envar> se používají pro zpracování parametrických L-systémů. Vrací pole parametrů libovolného typu a jejich počet. Tyto parametry jsou získány z pozice za identifikujícím znakem modulu. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Metody <envar>matchRight()</envar> a <envar>matchLeft()</envar> slouží především k ověřování kontextu. Pro svou funkci využívají metodu <envar>peekSymbol()</envar> pro nahlédnutí na levý nebo pravý nejbližší znak. Jelikož řetězce obsahují závorky, jsou implementovány i pomocné metody <envar>findMatchingRightBracket()</envar> a <envar>findMatchingLeftBracket()</envar> pro nalezení odpovídajícího protějšku k libovolné závorce. Podrobněji je celá funkcionalita nalezení kontextu popsána v kapitole <xref linkend="sec050503"/>.
            </simpara>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1> 
  <sect1 id="sec0503">
    <title>Implementace přepisovacích pravidel</title>
    <para>
      Potomci třídy <envar>AbstractFile</envar> zajišťují, aby byla pravidla správně načtena ze souboru. L-systému jsou předána jako klasický řetězec znaků. Ten však není vhodný pro samotný iterační proces. Proto se každé pravidlo zpracovává do struktury <envar>Rule</envar>. Různé typy L-systémů zpracovávají předané řetězce odlišně. Podrobněji se tomuto rozdělení věnuje kapitola <xref linkend="sec0505"/>. V této části jsou uvedeny implementační podrobnosti struktury <envar>Rule</envar>, do nichž všechny L-systémy svá přepisovací pravidla před iteračním procesem ukládají.  
    </para>
    <para>
      Jednou ze zásadních věcí bylo zakomponovat do pravidel nějaký mechanismus pro vyhodnocování výrazů. V pravidlech se totiž mohou výrazy vyskytovat hned na několika místech.  
      <itemizedlist mark='opencircle'>
        <listitem>
          <simpara>Každý modul na straně následníka může místo parametru obsahovat výraz, jež se vyhodnocuje až na základě parametrů předchůdce. 
          </simpara>
        </listitem>
        <listitem>
          <simpara>U parametrických L-systémů se může vyskytnout podmínka přepisu, která se musí před každým přepisem vyhodnotit. Při jejím nesplnění je pravidlo zamítnuto. 
          </simpara>
        </listitem>
        <listitem>
          <simpara>Stochastické L-systémy mívají nastaven pravděpodobnostní faktor, na jehož základě závisí pravděpodobnost vybrání daného pravidla pro přepis. Tento faktor se může rovněž vyhodnocovat z výrazu.
          </simpara>
        </listitem>
      </itemizedlist> 
    </para>
    <para>
      Pro zpracování výrazů byla vybrána knihovna <envar>FunctionParser</envar>. Jedná se o volně šířitelnou knihovnu, která poskytuje dostatečnou a navíc uživatelsky rozšiřitelnou funkcionalitu. Nabízí i možnosti optimalizace. Pro každý výraz, jenž je v pravidlech nalezen, je vytvořena jedna instance třídy <envar>FunctionParser</envar>. Pro zpracování slouží metoda <envar>Parse()</envar> s parametry zpracovávaného  výrazu a řetězce všech proměnných. Vyhodnocení se provádí metodou <envar>Eval()</envar>, která po předání pole s hodnotami proměnných vrací výsledek výrazu.
    </para>
    <para>
      Jako příklad je zde uvedeno pravidlo stochastického parametrického 2L-systému, kterým se zabývala kapitola <xref linkend="sec050503"/>.  
    </para>
    <para>
      <programlisting><![CDATA[
A(x,y) < B(z) > C(a,b,c):(x>abs(a-c))->B(b-1)FA(x/2,y/2):max(0,1-1/z*z)
   ]]></programlisting>
    </para>
    <para>
      Z tohoto zápisu je patrné, že pro všechny výrazy se používají proměnné předchůdce a kontextů. V tomto případě se jedná o <envar>x</envar>, <envar>y</envar>, <envar>z</envar>, <envar>a</envar>, <envar>b</envar> a <envar>c</envar>. Tyto znaky jsou uloženy ve struktuře <envar>Rule</envar> jako <envar>m_Variables</envar> a slouží k vytváření instancí třídy <envar>FunctionParser</envar>. Dále struktura obsahuje proměnné pro uložení znaků přechůdce, obou kontextů a ukazatele na instance pro vyhodnocení podmínky pravidla a pravděpodobnostního faktoru. Tyto proměnné pak slouží k výběru správného pravidla pro přepis modulu.
    </para>
    <para>
Jelikož se následník skládá z řetězců modulů a výrazů, je jeho zpracování složitější. Řetězce modulů jsou uloženy do instancí třídy <envar>StaticString</envar>. Jedná se o zjednodušenou variantu třídy <envar>LongString</envar>. Data jsou zde uložena ve stejné podobě. Rozdílem však je, že tento řetězec má neměnnou velikost. Pro účel krátkých neměnných řetězců následníka je tedy ideální, protože nezabírá tolik prostoru v paměti. Řetězce i výrazy se ukládájí do kontejneru typu <envar>std::vector</envar>. Jsou zde uloženy tak, aby mohly být při přepisu tohoto pravidla střídavě z kontejneru vybírány. Ukázka zpracovaného pravidla z předchozího příkladu je na obrázku <xref linkend="pic050301"/>.  
    </para>
    <figure float="1" id="pic050301">
      <title>Rozdělení následníka na řetězce modulů a výrazy</title>
	  	<mediaobject>
        <imageobject>
			    <imagedata fileref="050301.jpg" format="JPG"/>
	      </imageobject>
      </mediaobject>
	  </figure>  
    <para>
      Na obrázku <xref linkend="pic050301"/> je vidět, že pokud po sobě následují dva výrazy, může být řetězec mezi nimi prázdný. Šedě jsou znázorněny znaky, které jsou zahozeny, neboť jsou pro další zpracování nepotřebné. Při zpracování i následném přepisu pravidla se vždy začíná a končí výběrem řetězce modulů. Velikost kontejneru s řetězci je tedy vždy právě o jednu větší než velikost kontejneru s výrazy. Je to z toho důvodu, že často existují pravidla, která obsahují v následníkovi pouze řetězec a žádný výraz. Pokud nějaký výraz obsahují, vyskytuje se většinou někde uprostřed následníka. Proto je tento způsob zpracování optimální. 
    </para>
  </sect1>
  <sect1 id="sec0504">
    <title>Zpracování L-systémů</title>
    <para>
      L-systémy jsou implementovány jako potomci třídy <envar>AbstractLSystem</envar>. Abstraktní třída <envar>AbstractLSystem</envar> obsahuje několik metod sloužících jako rozhraní pro práci s L-systémy. 
      <itemizedlist mark='opencircle'>
        <listitem>
          <simpara>Pro inicializaci slouží metoda <envar>loadFromFile()</envar>, která načte všechna potřebná nastavení. Jako zdroj nastavení slouží instance potomků abstraktní třídy <envar>AbstractFile</envar>. 
          </simpara>
        </listitem>
        <listitem>
          <simpara>Pro provedení další iterace slouží metoda <envar>nextIteration()</envar>. Počet iterací lze ovlivnit i nastavením v konfiguračním souboru a v parametrech L-systému. Díky této metodě je však možné interaktivně provádět další iterace L-systému. 
          </simpara>
        </listitem>
        <listitem>
          <simpara>Metoda <envar>translate()</envar> vrátí vygenerované slovo. Slovo je vždy uvnitř třídy L-systému uloženo ve své nejvyšší iteraci. Na slově, které tato metoda vrátí, jsou ještě předtím provedeny finální úpravy. Aplikují se pravidla homomorfismů a odkazy na podřízené L-systémy se nahradí slovy, jež tyto L-systémy stejným způsobem vygenerovaly.
          </simpara>
        </listitem>
      </itemizedlist>   
      Veškerá funcionalita, jež je společná pro všechny typy L-systémů je implementována ve společném rodiči <envar>LSystem</envar>. Celý proces se dá rozdělit do tří fází, jejichž popis je obsahem následujících kapitol.
    </para>
    <sect2 id="sec050401">
      <title>Výběr nejvhodnějšího L-systému</title>
      <para>
        Zásuvný modul v současné podobě obsahuje tři různé třídy zpracovávající různé typy L-systémů. Liší se rychlostí a svými schopnostmi. Je tedy nutné, aby generátor vybral vhodný algoritmus. Stejně důležitý je i výběr u podřízených L-systémů. Každý soubor L-systému má nastaven svůj typ. Jedná se o výčet vlastností, které od třídy L-systému bude požadovat. Samotné třídy mají pak implementovanou statickou metodu <envar>isCapable()</envar>, na jejímž základě lze rozpoznat, zda daná třída požadavkům vyhovuje. Používá k tomu statický atribut <envar>capabilities</envar>, kde jsou schopnosti uloženy jako bitový součet. Jednotlivé schopnosti jsou definovány ve výčtu <envar>LSystemCapabilities</envar>. 
      </para>
      <para>
        Statická tovární metoda <envar>AbstractGenerator::createLSystem()</envar> usnadňuje vytváření nejvhodnější instance. Na základě typu načteného souboru automaticky vytvoří a vrátí vhodnou instanci L-systému. Testování, zda daný typ L-systému vyhovuje, zde probíhá od nejrychlejšího typu algoritmu k nejpomalejšímu. První typ, který splňuje všechny požadavky, je vybrán a použit. Jelikož se jedná o tovární metodu, která nemůže zaruči uvolnění paměti, je zde jako návratová hodnota použit inteligentní ukazatel <envar>boost::share_ptr</envar>.
      </para>
    </sect2>
    <sect2 id="sec050402">
      <title>Inicializační fáze</title>
      <para>
        Pravidla, která jsou předána jako řetězce, jsou v této fázi konvertována do struktury <envar>Rule</envar>. Ke konverzi slouží trojice metod. Metoda <envar>setAxiom()</envar> jednoduše přeloží řetězec znaků na vnitřní formát slova a nastaví jej jako počáteční slovo typu <envar>LongString</envar> pro iterační proces. 
      </para>
      <para>
        Nezbytnou součástí jsou metody pro přidání přepisovacích pravidel a homomorfismů. Struktura i funkce jsou u <envar>addRule()</envar> a <envar>addHomomorphism()</envar> dosti podobné. Způsob zpracování je v případě předchůdce shodný. Lišit se může zpracování následníka. Zpracování pravidel probíhá voláním jednotlivých funkcí struktury <envar>Rule</envar>, čímž se postupně prochází řetězec pravidla a instance struktury <envar>Rule</envar> je automaticky nastavována. Následující pseudokód ukazuje, jakým způsobem je zpracováno pravidlo parametrického stochastického 0L-systému.
      </para>
      <para>
        <programlisting><![CDATA[
přidejPřepisovacíPravidlo( řetězec zápisPravidla )
{
  Rule pravidlo;
  pravidlo.zpracujPředchůdce( zápisPravidla );
  pravidlo.zpracujPodmínku( zápisPravidla );
 
  // metoda zpracujStatickýŘetězecNásledníka() vrací:
  //    - true - pokud po zpracování následník pokračuje výrazem
  //    - false - pokud následník tímto statickým řetězcem končí 
  for( pravidlo.zpracujStatickýŘetězecNásledníka( zápisPravidla ))
  {
      pravidlo.zpracujVýrazVNásledníkovi( zápisPravidla );
  }      
  pravidlo.zpracujPravděpodobnostníVýraz( zápisPravidla );
}
     ]]></programlisting>
      </para>
    </sect2>
    <sect2 id="sec050403">
      <title>Přepisovací fáze</title>
      <para>
        Jednoznačně nejdůležitější fází je samotný iterační proces. Probíhá v krocích po jednotlivých iteracích. Začíná vždy s počátečním slovem, axiomem, v němž jsou při první iteraci všechny moduly nahrazeny dle přepisovacích pravidel. Tento postup se opakuje při každé iteraci na nově vzniklých slovech. Celý proces přepisu je zjednodušeně zobrazen v následujícím pseudokódu. 
      </para>
      <para>
        <programlisting><![CDATA[
LongString původníSlovo;
LongString novéSlovo;
for( všechny moduly v]]>&nbsp;<![CDATA[původníSlovo )
{
    najdi všechny pravidla, které mají aktuální modul jako předchůdce;
    if( existuje alespoň jedno takové)
    {
        if(vyber pravidlo)
        {
            novéSlovo.připoj( vygeneruj následníka modulu);
        }
        else
        {
            novéSlovo.připoj(použij pro daný modul pravidlo identity);
        }
    }
    else
    {
         novéSlovo.připoj(použij pro daný modul pravidlo identity);
    }
}
     ]]></programlisting>
      </para>
      <para>
        Prvotní prohledání pravidel vybere pouze ta, jež mají aktuální modul jako svého předchůdce. Takových pravidel může být hned několik. Mohou se lišit v kontextu, podmínce nebo mohou být vybrány na základě pravděpodobnosti. Výběr jednoho pravidla z této množiny provádí metoda <envar>selectRule()</envar>, v pseudokódu označená jako <quote>vyber slovo</quote>. Právě toto je funkce, v níž se jednotlivé L-systémy mohou nejvíce lišit a kde lze implementovat různé typy funkcionalit pro výběr pravidla. Detaily výběru pravidla u jednotlivých typů L-systémů rozebírá kapitola <xref linkend="sec0505"/>. Pokud žádné z pravidel nevyhovuje, použije se pravidlo identity, které pouze zkopíruje modul do nově vznikajícího slova. Vkládání do nového slova probíhá výhradně připojováním na jeho konec.  
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0505">
    <title>Rozdělení L-systémů</title>
    <para>
      Jak již bylo zmíněno v kapitole <xref linkend="ch02"/> o typech větvených struktur, je nutné pro modelování pokročilejších rostlinných organismů použít složitější typy L-systémů. Zároveň však není kvůli optimalizaci vhodné použít stejné L-systémy pro generování jednoduchých struktur. Různé typy L-systémů mají navíc různé formy zápisů svých přepisovacích pravidel. V následující kapitole jsou popsány specifika implementace jednotlivých typů L-systémů a také formáty zápisů pravidel, jež tyto L-systémy zpracovávají. Jsou zde rozebrány pouze vlastnosti, které nebyly společné a tak byly v minulé kapitole <xref linkend="sec0504"/> zmíněny jen okrajově.
    </para>
    <sect2 id="sec050501">
      <title>D0L-systémy</title>
      <para>
        Nejjednodušším L-systémem je tato varianta implementovaná třídou <envar>D0LSystem</envar>. Jak již název napovídá, zpracovává pouze deterministické bezkontextové L-systémy. Pro řadu modelů je tento typ dostatečný. Navíc je díky své jednoduchosti nejrychlejší. Zápis pravidel je ukázán na následujícím vzorovém příkladu.
      </para>
      <para>
        <programlisting><![CDATA[
A->A+(10)FBF
     ]]></programlisting>
      </para>
      <para>
        Tento typ nepodporuje zpracování výrazů. Každý následník se skládá pouze z jednoho řetězce typu <envar>StaticString</envar>. Iterační proces je v tomto případě vcelku jednoduchý. Vždy existuje maximálně jedno pravidlo, jehož předchůdce odpovídá právě zpracovávanému modulu původního řetězce. Toto pravidlo je také vždy vybráno a jeho následník je použit při přepisu.
      </para>
      <para>
        Příklad stromu generovaného D0L-systémem je na obrázku <xref linkend="pic05050201"/> (a). Jedná se o ternární strom, jenž se při každém větvení rozdělí právě na tři větve. Z obrázku je velmi zjevná pravidelnost, která je hlavní nevýhodou D0L-systémů.   
      </para>
    </sect2>
    <sect2 id="sec050502">
      <title>Parametrické stochastické bezkontextové L-systémy</title>
      <para>
        Tento typ L-systému umožňuje zpracovat parametrické i stochastické L-systémy, čímž značně rozšiřuje škálu možností. Díky parametrům lze vytvořit i mezotonické a akrotonické struktury. Náhodnost pak dovoluje vytvářet jedince rostlinných organismů s rozdílnou náhodnou strukturou, které však zároveň mají společné rodové znaky. Implementace se nachází v třídě <envar>ParStoch0LSystem</envar>. Tato třída zpracovává L-systémy ve tvaru, jak je popisuje kapitola <xref linkend="sec0205"/>. Příkladem mohou být následující pravidla zapsaná již v podobě, která je tímto L-systémem zpracovatelná.
      </para>
      <para>
        <programlisting><![CDATA[
A(x,y):(x>y)->A(x-1,y)FB(y/2)F:(x*y)
     ]]></programlisting>
      </para>
      <para>
        Jednotlivé části tohoto řetězce mají následující význam.
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara><emphasis>A(x,y)</emphasis> označuje předchůdce pravidla se dvěma parametry <emphasis>x</emphasis> a <emphasis>y</emphasis>. Tento údaj je povinný. 
            </simpara>
          </listitem>
          <listitem>
            <simpara><emphasis>(x>y)</emphasis> je příklad podmínky. Pokud pravidlo podmínku neobsahuje, může být podmínka nahrazena symbolem <emphasis>*</emphasis>, který značí, že je podmínka splněna vždy. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Následník <emphasis>A(x-1,y)FB(y/2)F</emphasis> je rozdělen a zpracován do struktury <envar>Rule</envar>.
            </simpara>
          </listitem>
          <listitem>
            <simpara>(x*y) je pravděpodobnostní faktor. Pokud se jedná o deterministické pravidlo, lze tento výraz vynechat a ukončit pravidlo posledním znakem následníka. V takovém případě je však nutné, aby žádné z pravidel s tímto předchůdcem neobsahovalo pravděpodobnostní faktor.
            </simpara>
          </listitem>
        </itemizedlist>      
      </para>
      <para>
        Výběr konkrétního pravidla provádí přetížená virtuální metoda <envar>selectRule()</envar>, která na vstupu obdrží už jen pravidla se shodujícím se předchůdcem. Tato pravidla je nutné dále protřídit. Pokud se nejedná o stochastický L-systém, vybere se pravidlo, které splňuje svou podmínku. V případě stochastického L-systému je běžné, že podmínku splňuje několik pravidel. Zde je zapotřebí vyhodnotit jejich pravděpodobnostní faktory a výsledky pak předat instanci pomocné třídy <envar>RandomIndex</envar>. Ta na základě těchto faktorů vybere náhodně jedno z pravidel, které je pak použito pro přepis.
      </para>
      <para>
        Ukázkou vložení parametrického prvku do modelu jsou obrázky <xref linkend="pic05050201"/> (b) a (c). Jedná se o jednoduchý D0L-systém ternárního stromu, ve kterém je však pomocí jednoduchých parametrických pravidel dosaženo jevu, kdy listy rostou pouze na mladších větvích. Starší a tlustší větve jsou, dle subapikálních pravidel růstu, bez listů. Listy na původním D0L-systému lze vytvořit pouze tak, že jsou rovnoměrně a pravidelně rozprostřeny na všech větvích. 
      </para>
      <para>
        Obrázek <xref linkend="pic05050201"/> (b) demonstruje použití pravděpodobnostního faktoru. Výrazy pro jeho výpočet byly zvoleny tak, že s rostoucí vdáleností od kořene klesá pravděpodobnost dělení větví. Je toho dosaženo pomocí dvou pravidel, z nichž jedno obsahuje dělení na dvě větve a druhé pouze krok vřed. Při prvních krocích je pravděpodobnost rozdělení téměř  stoprocentní. Kolem třetího kroku však prudce klesá a dále je naopak minimální. Podobných pravidel lze v přírodě nalézt celou řadu. Pomocí parametrických stochastických L-systémů je lze vcelku jednoduše nasimulovat.
      </para>
      <para>
        <figure float="1" id="pic05050201">
          <title>Bezkontextové L-systémy.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="05050201.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
    </sect2>
    <sect2 id="sec050503">
      <title>Parametrické stochastické kontextové L-systémy</title>
      <para>
        Aby byl zásuvný modul schopen zpracovávat dotazy a signály, obsahuje také třídu pro zpracování kontextových L-systémů. Použití kontextu také znamená jiný zápis pravidel.
      </para>
      <para>
        <programlisting><![CDATA[
A(x,y) < B(z) > C(a,b,c):(z > abs(a-c))->B(b-1)FA(x/2,y/2):max(0,1-1/z*z)
     ]]></programlisting>
      </para>
      <para>
        Oproti bezkontextovým gramatikám se zde navíc zadává levý a pravý kontext. Jeho zadání lze vynechat, avšak znaménka &lt; a > je nutné v řetězci pravidla zachovat. Zpracování podmínky i pravděpodobnostního faktoru je zde obdobné jako u bezkontextových L-systémů.    
      </para>
      <para>
        Nejdůležitějším rozšířením je schopnost ověřovat kontext předchůdce. Ověřování kontextu se řídí pravidly popsanými v kapitole o kontextových L-systémech <xref linkend="sec0204"/>. Pro tuto činnost byly implementovány metody <envar>matchRight()</envar> a <envar> matchLeft()</envar>. Jde o metody třídy <envar>LongString</envar> a vrací hodnotu <envar>integer</envar>, která informuje zda bylo ověřování úspěšné. V případě úspěchu tyto metody vrací pozici úspěšně ověřeného modulu. Jinak vrací -1. Metody instance třídy <envar>LongString</envar> tedy dostanou informace, jaký kontext a kde jej ověřovat a poté samy vyhodnotí výsledek. Jak vyplývá z výše zmíněných pravidel, je potřeba u L-systémů se závorkami provádět někdy ověření na více místech zároveň. Jedná se například o situaci symbolu vedle závorky nebo pokud je sousední symbol v seznamu ignorovaných znaků. Ověřovací metody tak uvnitř obsahují rekurzivní volání sebe sama, aby všechny tyto situace byly korektně vyhodnoceny. Pokud dochází při ověřování k větvení, je většinou nutné naleznout v řetězci správná místa pro ověření kontextu tak, aby byla respektována skutečná topologie modelu. K tomuto účelu slouží metody <envar>findMatchingRightBracket()</envar> a <envar>findMatchingLeftBracket()</envar>, které k nalezené závorce najdou její protějšek. Tímto umožní ověřovacímu mechanismu pokračovat za závorkou. Pseudokód fungování metody <envar>matchRight()</envar> zjednodušeně ukazuje princip fungování této metody. U metody <envar>matchLeft()</envar> je princip obdobný.
      </para>
      <para>
        <programlisting><![CDATA[
int matchRight( kontext,   /*symbol pravého kontextu*/
                pozice,    /*odkud hledat*/
                ignorovat  /*seznam ignorovaných znaků*/ )
{                                                              
  if ( slovo[pozice] == '[' )
    return matchRight( kontext, pozice + 1, ignorovat )  ||
           matchRight( kontext, findMatchingRightBracket(), ignorovat);
  else if ((slovo[pozice] == '[') || (ignorovat obsahuje slovo[pozice])
    return matchRight( kontext, pozice + 1, ignorovat );
  else if ( slovo[pozice] == kontext )
    return pozice;
  else
    return -1;
}
     ]]></programlisting>
      </para>
      <para>
        Levý i pravý kontext může stejně jako předchůdce mít své parametry, které je nutné načíst pro zpracování výrazů. Pozice modulů, získané jako návratové hodnoty během ověřování kontextů, slouží právě pro získání těchto parametrů. Díky rozšíření o zpracování kontextu mohl být do zásuvného modulu implementován také mechanismus pro zpracování dotazů. Podrobnějším popisem implementace dotazů se zabývá následující kapitola <xref linkend="sec0506"/>.
      </para>
      <para>
        Aplikaci dotazů i signálů pomocí kontextových L-systémů lze pozorovat na obrázcích <xref linkend="pic05050301"/>. Účelem bylo vytvořit modely, jež pomocí určité funkce mohou reagovat na své okolí. Reakce v tomto případě spočívá v ukončení růstu a šíření signálu o přerušení zpět směrem ke kořenům. Pokud se při šíření signálu nalezne místo, kde je možné vytvořit větvení, větev se rozdělí. Nově vytvořená větev pak pokračuje v růstu. Lze takto simulovat jev, který se obdobně vyskytuje i v přírodě. Pokud je totiž z nějakého důvodu zamezeno větvi dále růst, aktivuje se pupen na cestě ke kořenům. Zmíněné obrázky ukazují dva způsoby použití tohoto jevu. V případě obrázků (a) a (b) se jedná o simulaci zastřihování živého plotu. Jakmile větev opustí vymezený prostor, je zastřižena a růst pokračuje jinde. Obdobně funguje i druhý model na obrázcích (c) a (d). Zde je tímto mechanismem znemožněno prorůstání stromu do zdi.
      </para>
      <para>
        <figure float="1" id="pic05050301">
          <title>Stochastické parametrické 2L-systémy.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="05050301.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0506">
    <title>Dotazy</title>
    <para>
      Díky dotazům lze již během generování zjistit, kde a v jaké poloze se bude daný modul nacházet v prostoru. Rozšiřitelnost knihovny <envar>FunctionParser</envar> umožňuje do výrazů vkládat funkce, které pak mohou vrátit kterýkoli parametr polohy želvy. Toto připojení uživatelsky definovaných funkcí je prováděno pouze do výrazů, které tyto funkce obsahují. Je to z důvodu, že výrazy, které tyto funkce obsahují, nemohou být optimalizovány vnitřními algoritmy knihovny <envar>FunctionParser</envar>. Tyto dotazovací funkce jsou ve skutečnosti statickými metodami třídy <envar>Query</envar>. Každá tato metoda je bezparametrická a vrací hodnotu <envar>double</envar>. Pro každou souřadnici každého vektoru polohové matice želvy existuje jedna metoda. 
    </para> 
    <para>
      Třída <envar>Query</envar> slouží jako adaptér mezi třídami <envar>FunctionParser</envar> a <envar>QueryInterpret</envar>. Třída <envar>QueryInterpret</envar> je speciálně uzpůsobený interpret pro zpracování dotazů. Jeho fungování je podobné jako u třídy pro interpretaci geometrie, jež bude popsána v kapitole <xref linkend="sec0602"/>. Na rozdíl od ní však nevytváří žádnou geometrii a interpretuje jen symboly, které jsou důležité pro polohu želvy. Je implementován dle návrhového vzoru <emphasis>jedináček</emphasis>. 
    </para>
    <para>
      Na základě volání některé z metod třídy <envar>Query</envar> pak dostane pokyn k interpretaci slova. Interpretována je vždy jen ta část slova, která předcházela právě zpracovávanému modulu s dotazy. Nakonci interpretace je poloha želvy uložena a připravena pro dotazovací metody. Celá tato operace získání polohy je zajišťována vnitřní metodou <envar>update()</envar>. Problémem je, že hodnoty polohy želvy velice rychle stárnou a jejich obnovení je kvůli nutnosti interpretace řetězce časově náročná procedura. Pro omezení volání metody <envar>update()</envar> je implementován jednoduchý algoritmus. Pokud je některá souřadnice přečtena podruhé, předpokládá se, že se jedná o jiný modul a je tedy třeba provést obnovu. Na obrázku <xref linkend="pic050601"/> lze vidět, jakým způsobem vypadá pravidlo s dotazy a jak se jednotlivé dotazy pomocí instance třídy <envar>QueryInterpret</envar> vyhodnocují. U dotazů, které si vynutí provedení interpretace slova je spolu s důvodem uvedena metoda <envar>update()</envar>. Ostatní dotazy obdrží odpověď okamžitě. 
    </para>
    <para>
      <figure float="1" id="pic050601">
        <title>Zpracování dotazů třídou <envar>QueryInterpret</envar></title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="050601.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>  
    </para>
    <para>
      Instance třídy <envar>QueryInterpret</envar> tedy při prvním volání dotazu <envar>positionX()</envar> zjistí všechny souřadnice polohy želvy. Poté je možné vracet jednotlivé souřadnice polohy. Jakmile se jeden z dotazů zopakuje, provede se obnova polohy želvy a tedy i nová interpretace slova. Stejným způsobem reaguje interpret na dotazy týkající se aktuálních směrových vektorů želvy.
    </para>
    <para>
      Zpracováním dotazů lze tedy do řetězce slova dostat poziční hodnoty ještě před vykreslovací fází. Kombinací s kontextovými pravidly s podmínkou lze dosáhnout toho, že některá pravidla budou použita jen při určitých hodnotách těchto dotazů. Druhou možností je využít tyto hodnoty ke změně parametrů modulů. Například v případě popínavých rostlin lze na základě polohy a směru rostoucí větve vyhodnotit, kterým směrem by se měla daná větev vyvíjet a podle toho pak ovlivnit její směr.
    </para>  
  </sect1>
  <sect1 id="sec0507">
    <title>Podřízené L-systémy</title>
    <para>
      Problematiku návrhu modelu pomocí L-systémů lze rozdělit na několik úrovní. Pro lepší kontrolu, přehlednost a také nastavitelnost je lepší jednotlivé dílčí celky hierarchicky seřadit. U botanických organismů se může jednat například o rozdělení na rostlinné orgány. Jde však samozřejmě jít i hlouběji. Výhodou tohoto přístupu je modularita. Každý takovýto dílčí L-systém má svá vlastní nastavení a může být použit v libovolném počtu jiných L-systémů. Pokud je tedy například vytvořen L-systém pro list, je velice jednoduché přidat jej jako podsystém ke všem L-systémům stromů stejného druhu.  
    </para> 
    <para>
      Každý L-systém si své podsystémy spravuje sám. Po jejich načtení pomocí metod třídy <envar>AbstractFile</envar> je každý L-systém inicializován a zpracován podobně jako ve třídě <envar>LSystemGenerator</envar>. Každému podsystému je přiřazeno unikátní číslo. Pod ním je tento systém reprezentován v řetězci pomocí modulu <envar>#(L-System_ID)</envar>. Všechna slova jsou vygenerována a uložena v nadřazeném L-systému. Do řetězce jsou vložena až po ukončení iteračního procesu, kdy jsou všechny moduly <envar>#()</envar> nahrazeny vygenerovanými slovy. Na začátku a konci každého slova podsystému jsou speciální moduly <envar>$</envar>, jež poté informují interpret o změně L-systému. Ten pak dle parametrů tohoto modulu přepne na zpracování řetězce dle odpovídajících nových parametrů. Neboť je toto chování dosti podobné zpracování závorek, věnuje se jim společná kapitola o implementaci zásobníku <xref linkend="sec060201"/>. 
    </para>
  </sect1>
</chapter>
<chapter id="ch06">
  <title>Interpretace slov</title>
  <para>
    Předchozí kapitola se věnovala výhradně iteračnímu procesu L-systémů za účelem vytvoření slova, jež bude reprezentovat požadovaný model. V této kapitole budou podrobněji rozvedeny techniky, které takto vygenerované slovo interpretují a vytváří jeho geometrickou podobu. Pro interpretaci byla zvolena výše zmíněná technika želví grafiky. Jednotlivé moduly pak slouží jako příkazy želvě k různým úkonům. Díky abstrakci na úrovni modulů lze vybírat z různých technik, kterými želva kreslí, a tak vytvářet rozmanitější modely.
  </para>
  <para>
    Kromě samotné geometrie je nutné řešit i jiné otázky týkající se zobrazení modelu. Jedná se zejména o mapování textur a o úroveň detailů. Na této vrstvě je také možné přidat i různé vlivy okolí. Jelikož se jedná pouze o interpretaci, tyto vlivy nijak nemohou ovlivnit strukturu výsledného modelu. Mohou však globálně ovlivnit celý model. Lze tak jednoduše přidat modelu závislost na některých silách jako je gravitace. Jinou možností je přiblížení rostlin svým reálným předlohám pomocí malé náhodnosti úhlů. Modely tak ztratí svou viditelnou matematickou přesnost.
  </para>
  <para>
    Jako rozhraní pro interpretaci slov slouží abstraktní třída <envar>AbstractInterpret</envar>. Implementováni jsou dva potomci. <envar>TurtleInterpret</envar> zpracovává věškeré příkazy želvy a slouží k vytváření geometrie. <envar>QueryInterpret</envar> provádí zpracování dotazů ohledně polohy želvy. Tento interpret zpracovává jen vybrané příkazy. Podrobněji byl popsán v kapitole <xref linkend="sec0506"/>.  
  </para>
  <para>
    Řetězec generovaný L-systémem je přetypován na nový typ. Z instance třídy <envar>LongString</envar> je převeden na instanci třídy <envar>ParseableString</envar>. Jedná se o jednoduchou třídu, která obsahuje metody pro dopředné procházení řetězce a získávání modulů a jejich parametrů.
  </para>
  <sect1 id="sec0601">
    <title>Spojení s grafem scény</title>
    <para>
      Pro zobrazení generované geometrie je důležité napojení na graf scény. Při vytváření interpretu je mu konstruktorem předán ukazatel na rodiče v grafu. Vzhledem k tomu, že slovo může díky mechanismu podsystémů obsahovat řetězce několika L-systémů mající různé parametry, je nutné i při vytváření geometrie tyto L-systémy oddělit. Díky grafu scény je k dispozici ideální řešení. Pro každý L-systém vytvoří interpret jeden uzel s geometrií, jež bude obsahovat i svá nastavení. Tyto uzly jsou instancemi třídy <envar>LSGeode</envar>. Tato třída je rozšířením třídy <envar>osg::Geode</envar>. Navíc obsahuje metody pro volbu správného typu želvy a také metody pro předání výchozích hodnot nastavení želvy. Všechny tyto hodnoty jsou získány z parametrů, jež se načítají při zpracování souborů L-systémů potomky třídy <envar>AbstractFile</envar>.  
    </para> 
    <para>
      Při inicializaci instance <envar>LSGeode</envar> dochází také k nastavení uzlu. Nastaví se textura, materiály a další vlastnosti. Veškeré parametry jsou zpracovány a konvertovány do takové podoby, aby při generování byly buď již nastaveny nebo rychle připraveny ke zpracování.
    </para>
  </sect1>
  <sect1 id="sec0602">
    <title>Interpretace pomocí želví grafiky</title>
    <para>
      Úkolem interpretu je projít celé slovo typu <envar>ParseableString</envar> a moduly, které rozpozná, převést na příkazy. Pro tento převod slouží metoda <envar>parse()</envar>. Každá třída interpretu obsahuje v této metodě svou sadu příkazů, které umí interpretovat. Následně pak volá metody pro manipulaci s želvami na zásobníku nebo nastavuje a kreslí želvou, která je na vrcholu zásobníku.   
    </para> 
    <sect2 id="sec060201">
      <title>Zásobník pro ukládání želvích instancí</title>
      <para>
        Pro zpracování slov, které obsahují závorky a podřízené L-systémy, je nutná dobrá implementace zásobníku pro želvy. K tomuto účelu slouží třída <envar>TurtleStack</envar>, která poskytuje standardní funkce zásobníku. Je však uzpůsobena pro použití v tomto zásuvném modulu. Při interpretaci se pracuje vždy pouze se želvou, která je aktuálně na vrcholu zásobníku. Existují proto speciální moduly, jež dokáží s obsahem zásobníku manipulovat.
      </para> 
      <para>
        <variablelist>
    			<varlistentry>
    				<term> [ </term>
    				<listitem>
    					<para>Tato závorka označuje počátek nové vedlejší větve. V tomto stavu je nutné vytvořit metodou <envar>push()</envar> na zásobníku novou želvu, která se vykreslováním této větve bude zabývat. Parametry i typ si tato želva nastaví podle dosavadní želvy na vrcholu zásobníku.</para>
    				</listitem>
    			</varlistentry>
    			<varlistentry>
    				<term> ] </term>
    				<listitem>
    					<para>Ukončení vedlejší větve je signalizováno tímto symbolem. Želva je z vrcholu zásobníku odstraněna a další geometrii generuje želva pod ní. V růstu tedy pokračuje hlavní větev.</para>
    				</listitem>
    			</varlistentry>
    			<varlistentry>
    				<term> $(x) </term>
    				<listitem>
    					<para>Jednotlivé L-systémy mají již od svého načtení přiřazen jednoznačný identifikátor. Symbol dolaru s jedním parametrem oznamuje interpretu, že má dojít ke změně L-systému. Podle identifikátoru v parametru modulu je vybrán správný L-systém a jeho odpovídající uzel s geometrií <envar>LSGeode</envar>. Ten už poté ví, který typ želvy použít a jaké výchozí parametry jí nastavit. Některé parametry, jako je matice polohy, mohou být nastaveny podle dosavadní želvy na vrcholu zásobníku. S nově vytvořenou želvou se pak na zásobníku provede operace <envar>push()</envar>.</para>
    				</listitem>
    			</varlistentry>
    			<varlistentry>
    				<term> $ </term>
    				<listitem>
    					<para>Ukončení slova podsystému signalizuje symbol dolaru bez parametru. Z vrcholu zásobníku je odstraněna želva a ve vykreslování pokračuje želva nadřazeného L-systému.</para>
    				</listitem>
    			</varlistentry>
    		</variablelist>	
      </para>
    </sect2>
    <sect2 id="sec060202">
      <title>Želví rozhraní</title>
      <para>
        Pro větší modularitu byl při návrhu zvolen model, jenž umožňuje použití libovolného množství typů želv. Lze tedy generovat různou geometrii pomocí stejných příkazů. Všechny třídy želv dědí z abstraktní třídy <envar>AbstractTurtle</envar>. Tato třída obsahuje rozhraní pro úplnou kontrolu želvy. Většinu tvoří metody pro zpracování příkazů, které se ve slovech vyskytují jako moduly. Kromě toho obsahuje metody k propojení s uzlem geometrie. Do něj pak přímo ukládá veškerou geometrii. K propojení dochází při vkládání želvy na vrchol zásobníku. Je zde k dispozici i několik metod pro vykreslování pomocné geometrie při ladění.
      </para>
      <para>
        Každá želva má celou řadu parametrů, jež se mohou během vykreslování neustále měnit. Proto obsahuje strukturu <envar>TurtleProperties</envar>, která všechny tyto hodnoty uchovává. Parametry si želvy mezi sebou předávají při operacích na zásobníku. Pokud se jedná o první želvu L-systému, nahrají se výchozí parametry z instance třídy <envar>LSGeode</envar>.
      </para>
    </sect2>
    <sect2 id="sec060203">
      <title>Želví příkazy</title>
      <para>
        Každá želva interpretuje celou řadu příkazů. Ne všechny želvy musí nutně implementovat všechny příkazy. Některé mohou být úzce specializované. Obecně lze příkazy rozdělit do několika kategorií. 
      </para> 
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara><emphasis>Základní pohybové příkazy</emphasis> &mdash; Většina želv má implementovány základní příkazy pro pohyb. Metody pro pohyb jsou společné a nachází se v abstraktní třídě <envar>MovingTurtle</envar>. Umožňují například pohyb želvy dopředu a natáčení kolem všech os. Želva se může pohybovat i bez generování geometrie pouze za účelem přemístění se.
            </simpara>
          </listitem>
          <listitem>
            <simpara><emphasis>Pokročilé pohybové příkazy</emphasis> &mdash; Jedná se o nestandardní pohyby želvy, jako je otočení do protisměru nebo vyrovnání náklonu do vodorovné polohy.
            </simpara>
          </listitem>
          <listitem>
            <simpara><emphasis>Změna stavových proměnných</emphasis> &mdash; Řadu parametrů želvy lze během interpretace měnit. Je tak možné například prodloužit délku kroku nebo měnit výchozí úhel rotace.
            </simpara>
          </listitem>
          <listitem>
            <simpara><emphasis>Nastavení vnějších vlivů</emphasis> &mdash; Některé příkazy mohou ovlivnit reakci želvy na globální vnější vlivy. V případě gravitace se může například jednat o změnu pružnosti větve. 
            </simpara>
          </listitem>
        </itemizedlist> 
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0603">
    <title>Generování geometrie</title>
    <para>
      Z definice želvy vyplývá, že ke kreslení dochází pouze při jediném typu příkazu. Jedná se o krok vpřed. V případě trojrozměrné implementace v zásuvném modulu LSystem dochází při interpretaci tohoto příkazu ke generování geometrie. Implementačně se jedná o metodu <envar>drawStep()</envar> deklarovanou ve třídě <envar>AbstractTurtle</envar>. Její konkrétní definice záleží na typu želvy.  Může se jednat o planární i trojrozměrné objekty, nahrané modely a jiné. Veškerá geometrie se ukládá do jedné či více instancí třídy <envar>osg::Geometry</envar>, která slouží jako úložiště veškeré geometrie instance třídy <envar>LSGeode</envar>. Každá želva má uložen ukazatel na tyto kontejnery s geometrií. Díky tomuto propojení uzlů geometrie s želvami na zásobníku je pak geometrie vykreslena dle parametrů jednotlivých L-systémů.
    </para>
    <sect2 id="sec060301">
      <title>Válce s klouby</title>
      <para>
        Jedná se o jednoduché vykreslování grafiky, jež simuluje želvou kreslenou čáru. Pro každý krok se vygeneruje právě jeden válec o předdefinovaném poloměru a délce jednoho kroku. Umístěn je tak, aby přímka procházející středem obou jeho podstav byla totožná s přímkou která prochází krajními body kroku želvy. Protože by při rotaci mezi jednotlivými kroky docházelo k nespojitostem v geometrii, umisťují se na podstavy válců koule, které plní funkci kloubu. Při shodném poloměru s válci nespojitosti vyplní. Pro optimalizaci je při implementaci použita pouze polokoule. Lze také nastavit detail jednotlivých těles pomocí parametru <envar>ContourDetail</envar>.  
      </para>
      <para>
        <figure float="1" id="pic06030101">
          <title>Generování válců s klouby.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="06030101.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
    </sect2>
    <sect2 id="sec060302">
      <title>Spojité válce</title>
      <para>
        Želvy tohoto typu generují, podobně jako předchozí typ geometrii, složenou z válců. Díky odlišnému přístupu však zde nedochází k nespojitostem geometrie při rotacích želvy mezi jednotlivými kroky. Každý krok je zde rozdělen na dva půlkroky. Po provedení prvního půlkroku je pozice želvy uložena jako kontrolní bod a je použita jako bod pro generování kontury, která tvoří horní podstavu předešlé válcovité geometrie a zároveň spodní podstavu geometrie kroku, který bude případně následovat. Rovina kontury je vždy kolmá na směr pohybu želvy.  
      </para>
      <para>
        <figure float="1" id="pic06030201">
          <title>Generování spojité válcovité geometrie.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="06030201.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
      <para>
        Geometrie v tomto případě tedy přesně nekopíruje trasu želvy. Generuje však vizuálně mnohem lepší výsledek než v případě válců s klouby a navíc kvůli absenci polokoulí obsahuje menší množství trojúhelníků. V tomto případě lze také mnohem lépe vyřešit navazování textur.
      </para>
    </sect2>
    <sect2 id="sec060303">
      <title>Obdélníky</title>
      <para>
        Předchozí dva typy želv jsou vhodné pro tvorbu stonků a kmenů. Pro modely stromů je implementována tato třída pro tvorbu listů. Stromy obsahují velké množství tvarově málo rozmanitých listů. Právě pro tento účel je vhodná želva typu <envar>Rectangle</envar>. Při kroku vpřed vytváří vždy pouze obdélník. Tento obdélník je pak vhodný pro nanášení textury, jež díky průhlednosti list jednoduše a tvarově přesně vykreslí. Velikost obdélníku se řídí běžnými parametry želvy. Jde o délku kroku a tloušťku čáry.  
      </para>
      <para>
        <figure float="1" id="pic06030301">
          <title>Generování geometrie pro listy.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="06030301.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
      <para>
        Listy stromů je vhodné vytvořit pomocí samostatného podřízeného L-systému. Pokud je pro interpretaci slov listů použita tato želva, nemusí být L-systém, jenž toto slovo generuje, nijak složitý. Většinou postačí jeden krok kupředu společně s případnými rotacemi.
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0604">
    <title>Textury</title>
    <para>
      Pro reálné zobrazení rostlinných organismů je důležité nanášení textur. U generované geometrie je tedy potřebné dbát na správné generování souřadnic textury. Zásuvný modul LSystem umožňuje nanášení difuzních textur na navazující válcovité a jednoduché planární objekty. Je tedy možné použít texturu jak pro geometrii větví, tak pro geometrii listů.
    </para>
    <sect2 id="sec060401">
      <title>Mapování textur na navazující válce</title>
      <para>
        Na geometrie větví se obvykle nanášejí textury kůry nebo stonku, které jsou vytvořeny tak, aby při jejich skládání nebyly viditelné okraje textur. Z důvodu válcovitého tvaru se generování texturových souřadnic vždy řídí podle obvodu podstav válce. Aby textury správně navazovaly, je nutné, aby se po obvodu opakovaly v celočíselných násobcích. Tento násobek je možné nastavit parametrem <envar>TextureSRepeatings</envar>, který nastavuje, kolikrát se bude textura podél obvodu opakovat.
      </para>
      <para>
        <figure float="1" id="pic06040101">
          <title>Mapování textury na válce</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="06040101.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
      <para>
        Směr podél obvodu odpovídá texturové souřadnici <emphasis>s</emphasis>. Směr pohybu želvy kupředu pak určuje směr texturové souřadnice <emphasis>t</emphasis>. Tato souřadnice se vždy přizpůsobuje obvodu větve tak, aby byl přibližně zachován poměr stran a textura tak působila přirozeně. Opakování textury v tomto podélném směru tedy nemusí být celočíselné a hodnota souřadnice z konce jednoho válcovitého dílu se přenáší dále jako počáteční hodnota pro další krok. Přenáší se však pouze desetinná část, neboť pouze ta je důležitá pro korektní navázání textury. Podobný princip nanášení textury lze nalézt i v práci <citation>Mech97</citation>. Implementace v tomto zásuvném modulu navíc umožňuje opakování ve směru <emphasis>s</emphasis>. Způsob a příklad generování texturových souřadnic je znázorněn na obrázku <xref linkend="pic06040101"/>. Celý válec představuje jeden krok želvy. Kolem obvodu se zde textura opakuje dvakrát. Podélná textura je pak adekvátně přizpůsobena.
      </para>      
    </sect2>
    <sect2 id="sec060402">
      <title>Mapování textur na obdélníky</title>
      <para>
        Pro nanášení textury na objekty listů je použita jednoduchá metoda mapování. Jelikož je každý list reprezentován jedním obdélníkem, jeho krajní body odpovídají krajním bodům textury. Tvaru listu je dosaženo pomocí průhlednosti textury. Díky tomu je zapotřebí mnohem méně geometrie. Toto řešení však s sebou nese jedno úskalí. <emphasis>OpenSceneGraph</emphasis> obsahuje pro správné zobrazení průhledných objektů speciální koš. Při vykreslování postupně vybírá z koše jednotlivé objekty typu <envar>osg::Geometry</envar> seřazené podle vzdálenosti od pozorovatele odzadu dopředu. Díky tomu jsou i průhledné objekty vykresleny korektně. Kvůli optimalizaci je však vhodné mít všechny objekty listů v jedné geometrii, což však může mít za následek špatné seřazení objektů. Tato optimalizace tak může někdy způsobovat na okrajích listů <emphasis>halo</emphasis> efekt. Pro odstranění tohoto efektu je možné nastavit parametr <envar>SeparateGeometryForTranslucent</envar>, který vynutí použití oddělených geometrií pro každý objekt listu. Listy jsou v tomto módu korektně seřazeny. Vzhledem k velkému počtu instancí třídy <envar>osg::Geometry</envar> však dochází ke snížení výkonu.
      </para>
      <para>
        <figure float="1" id="pic06040201">
          <title>Ukázka mapování textur listů.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="06040201.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0605">
    <title>Minimalizace příčného náklonu</title>
    <para>
      Interpretace želví grafikou je bezesporu jednou z velmi univerzálních metod pro interpretaci L-systémů. Přináší však s sebou i možné nevýhody. Jednou z nich je deformace válců při provádění rotace kolem osy
      <inlineequation>
        <alt role="tex">\vec{H}</alt>
      </inlineequation>.
      V každém kroku želva generuje body válcovité geometrie podle své kontury a řídí se svou aktuální orientací. Poloha bodů závisí na orientaci vektoru 
      <inlineequation>
        <alt role="tex">\vec{L}</alt>
      </inlineequation>.
      Pokud v jednom kroku dojde k příčnému náklonu o příliš velký úhel, může dojít k deformaci geometrie.
    </para>
    <para>
      <figure float="1" id="pic060502">
        <title>Porovnání vzhledu geometrie bez (a) a s (b) použitím minimalizace příčného náklonu při interpretaci řetězce <envar>F/F/F/F/F/F</envar>.</title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="060502.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>  
    </para>
    <para>Někdy může být tento efekt žádoucí, většinou je ale lepší jej odstranit. Řešením může být jeden z několika algoritmů pro minimalizaci příčného náklonu. Pro zásuvný modul <emphasis>LSystem</emphasis> byla zvolena Bloomenthalova metoda minimalizace rotace, kterou Bloomethal obdobně použil při generování svého modelu <emphasis>Mohutný javor</emphasis>. Kromě polohové matice želvy se zavádí navíc matice kontury. Tato matice pak slouží ke generování bodů kontury a vytvoření válcovité geometrie, která nepodléhá příčnému náklonu. Je vytvořena na základě ortogonální báze vektorového prostoru 
      <inlineequation>
        <alt role="tex">( \vec{H} , \vec{V} , \vec{H} \times \vec{V} )</alt>
      </inlineequation>, kde 
      <inlineequation>
        <alt role="tex">\vec{H}</alt>
      </inlineequation>
      je směrový vektor želvy a 
      <inlineequation>
        <alt role="tex">\vec{V}</alt>
      </inlineequation>
      je vektor, podle něhož se bude generovat geometrie. Tento vektor je před interpretací slova nastaven jako shodný s vektorem 
      <inlineequation>
        <alt role="tex">\vec{L}</alt>
      </inlineequation>.  
    </para>
    <para>
      <figure float="1" id="pic060501">
        <title>Princip minimalize příčného náklonu u dvou následujících bází polohy želvy.</title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="060501.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>  
    </para>
    <para>
      Při každém kroku želvy kupředu jsou v metodě <envar>adjustMatrices()</envar> upraveny hodnoty vektorů. Pokud označíme 
      <inlineequation>
        <alt role="tex">\vec{H_1}</alt>
      </inlineequation> 
      jako směrový vektor želvy původní báze a 
      <inlineequation>
        <alt role="tex">\vec{H_2}</alt>
      </inlineequation>
       označíme směrový vektor želvy po vykonaném kroku vpřed, můžeme novou bázi získat otočením původní ortogonální báze kolem osy 
      <inlineequation>
        <alt role="tex">\vec{H_1} \times \vec{H_2}</alt>
      </inlineequation>
       o úhel, který svírají vektory 
      <inlineequation>
        <alt role="tex">\vec{H_1}</alt>
      </inlineequation>
      a
      <inlineequation>
        <alt role="tex">\vec{H_2}</alt>
      </inlineequation>. Vektor 
      <inlineequation>
        <alt role="tex">\vec{V}</alt>
      </inlineequation>
      pak bude vždy ve stejné rovině s vektorem 
      <inlineequation>
        <alt role="tex">\vec{L}</alt>
      </inlineequation>. Na rozdíl od něj však
      <inlineequation>
        <alt role="tex">\vec{V}</alt>
      </inlineequation>
      nebude podléhat příčnému náklonu. 
    </para>
  </sect1>
  <sect1 id="sec0606">
    <title>Odezva na směrové podněty</title>
    <para>
      Rostlinné organismy v přírodě reagují na celou řadu podnětů. Některé podněty, jako je gravitace, mohou mít na vzhled rostliny zásadní vliv a implementací reakce na tyto podněty lze modely podstatně přiblížit realitě. Pro směrové podněty se používá termín <emphasis>tropismus</emphasis>. Jedná se o změnu orientace rostlinného organismu na základě nějakého podnětu či podráždění <citation>Bell08</citation>. Tento podnět je v případě tropismu veden vždy v nějakém směru. V přírodě existuje mnoho druhů tropismu. Některé z nich jsou velmi důležité i zajímavé pro simulaci.  
    </para>
    <variablelist>
			<varlistentry>
				<term>Geotropismus/Gravitropismus</term>
				<listitem>
					<para>V rámci simulace biomechanických jevů se jedná o nejdůležitější formu tropismu. Geotropismus je reakce rostlinného organismu na gravitaci. Příkladem může být směřování větví pod svou tíhou k zemi nebo naopak růst stonku proti gravitaci.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Fototropismus</term>
				<listitem>
					<para>Dalším často simulovaným jevem je reakce na světelné podmínky, kdy se orgány rostlin orientují směrem k největšímu zdroji světla. Obdobnou formou je pohyb za sluncem nazývaný heliotropismus.</para>
				</listitem>
			</varlistentry>
		</variablelist>	
    <para>
      Při aplikaci těchto vlivů na želvu, dochází při každém kroku želvy ke korekci jejího směru tak, aby respektovala síly, které na ní působí.
    </para>	
    <sect2 id="sec060601">
      <title>Geotropismus</title>
      <para>
        Pro implementaci tropismu byla použita metoda založená na výpočtu zrychlení momentu síly. Lze tak vypočítat úhel, o který je třeba otočit směrový vektor želvy 
        <inlineequation>
          <alt role="tex">\vec{H}</alt>
        </inlineequation>
        směrem k vektoru podnětu 
        <inlineequation>
          <alt role="tex">\vec{T}</alt>
        </inlineequation>.  
      </para>
      <equation>
        <title>Výpočet korekčního úhlu při geotropismu.</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="math06060101.png"/>
          </imageobject>
          <textobject role="tex">
            <phrase>\beta = e  \vert \vec{H} \times \vec{T} \vert </phrase>  
          </textobject>
        </mediaobject>
      </equation>
      <para>
        Důležitou roli zde hraje parametr 
        <inlineequation>
          <alt role="tex">e</alt>
        </inlineequation>, 
        který udává přizpůsobivost danému podnětu. Například u větví tento parametr udává jejich pružnost. V zásuvném modulu je geotropismus implementován odděleně od ostatních tropismů, neboť se jedná o velmi důležitý podnět. Úhel podnětu směřuje vždy směrem k zemi (proti směrovému vektoru 
        <inlineequation>
          <alt role="tex">\vec{H}</alt>
        </inlineequation>
         na počátku interpretace). Nastavení se provádí pomocí parametru <envar>GeotropismElasticity</envar>.
      </para>
      <para>
        <figure float="1" id="pic06060101">
          <title>Ukázka vlivu geotropismu na ternární strom. Při generování stromů na obrázcích <envar>a</envar>, <envar>b</envar>, <envar>c</envar> a <envar>d</envar> byly použity hodnoty pružnosti 0.0, 0.1, 0.2 a 0.3.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="06060101.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
      <para>
Při každém kroku želvy je metodou <envar>adjustMatrices()</envar> vypočten pomocí výše zmiňovaného vzorce nový směrový vektor a zbývající ortogonální vektory jsou adekvátně dopočítány. 
      </para>
    </sect2>
    <sect2 id="sec060602">
      <title>Diatropismus</title>
      <para>
        Tento vzorec lze dále rozšířit na obecnější formu <xref linkend="eq06060201"/>. Jedná se o takzvaný diatropismus, při němž se rostlinné orgány snaží se směrovým vektorem podnětu svírat úhel 
        <inlineequation>
          <alt role="tex">\gamma</alt>
        </inlineequation>. Tato obecná forma tropismu lze využít pro modelování různých jevů. Na obrázku lze vidět ovlivnění stromu při různých nastaveních. Implementace je obdobná jako u geotropismu. Navíc jsou však dispozici parametry <envar>TropismAngle</envar> pro nastavení úhlu 
        <inlineequation>
          <alt role="tex">\gamma</alt>
        </inlineequation>
        a <envar>TropismVector</envar> pro nastavení úhlu tropismu. Pružnost se zde nastavuje parametrem <envar>TropismElasticity</envar>.
      </para>
      <para>
Pro každý model lze nastavit maximálně jeden takový podnět. Zároveň však díky oddělené implementaci lze vždy zároveň nastavit i geotropismus.  
      </para>
      <equation id="eq06060201">
        <title>Výpočet korekčního úhlu při diatropismu.</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="math06060201.png"/>
          </imageobject>
          <textobject role="tex">
            <phrase>\beta = e \left( \cos ( \gamma ) - \sin ( \gamma )  \frac{ \vec{H} \cdot \vec{T} }
                    { \bigl\vert \vec{H} \times \vec{T} \bigr\vert }  \right)</phrase>  
          </textobject>
        </mediaobject>
      </equation>
      <para>
        <figure float="1" id="pic06060201">
          <title>Stromy na obrázcích jsou generovány s aplikovaným plagiotropismem dle parametrů v tabulce <xref linkend="tab06060201"/>.</title>
  		  	<mediaobject>
            <imageobject>
  				    <imagedata fileref="06060201.jpg" format="JPG"/>
  		      </imageobject>
          </mediaobject>
  		  </figure>  
      </para>
      <para>
    		<table id="tab06060201" frame="topbot" tocentry="1" pgwide="1">
    			<title>Parametry diatropismu.</title>
    				<tgroup cols="4" colsep="0" rowsep="0">
    				<thead>
    					<row>
    						<entry colsep="1">Obrázek</entry>
    						<entry>Pružnost</entry>
    						<entry>Směrový vektor diatropismu</entry>
    						<entry>Úhel diatropismu</entry>
             	</row>
    				</thead>
    				<tbody>
    					<row rowsep="0">
    						<entry colsep="1">a</entry>
    						<entry colsep="0">0.17</entry>
    						<entry colsep="0">(0.0,1.0,0.0)</entry>
    						<entry colsep="0">60</entry>							
    					</row>
    					<row rowsep="0">
    						<entry colsep="1">b</entry>
    						<entry colsep="0">0.2</entry>
    						<entry colsep="0">(0.0,1.0,0.0)</entry>
    						<entry colsep="0">90</entry>							
    					</row>
    					<row rowsep="0">
    						<entry colsep="1">c</entry>
    						<entry colsep="0">0.09</entry>
    						<entry colsep="0">(0.7,1.0,0.0)</entry>
    						<entry colsep="0">0</entry>							
    					</row>
    					<row rowsep="0">
    						<entry colsep="1">d</entry>
    						<entry colsep="0">0.2</entry>
    						<entry colsep="0">(0.0,0.0,1.0)</entry>
    						<entry colsep="0">90</entry>							
    					</row>
    				</tbody>
    			</tgroup>
    		</table>
    	</para>
    </sect2>
  </sect1>
  <sect1 id="sec0607">
    <title>Fluktuace úhlů</title>
    <para>
      Jedním z velkých kladů L-systémů je, že každé slovo přesně odpovídá generované rostlině. Někdy je však žádoucí, aby bylo možné pomocí minimálních změn vytvořit organismus, který bude topologicky shodný, ale vizuálně mírně odlišný. Tímto způsobem lze z jednoho již vygenerovaného slova vytvářet ne zcela identické jedince. Druhým argumentem pro zavedení toho mechanismu je často absolutní matematická přesnost úhlů generovaných rostlin. Mírným náhodným roztřesením úhlů lze odstranit viditelnou pravidelnost a dosáhnout tak mnohem lepších vizuálních výsledků.
    </para>
    <para>
      <figure float="1" id="pic060701">
        <title>Obrázek <envar>a</envar> je vykreslen bez fluktuace úhlů. Obrázky <envar>b</envar>, <envar>c</envar> a <envar>d</envar> mají fluktuaci nastavenou na 50% a semínko 1, 2 a 3.</title>
		  	<mediaobject>
          <imageobject>
				    <imagedata fileref="060701.jpg" format="JPG"/>
		      </imageobject>
        </mediaobject>
		  </figure>  
    </para>
    <para>
      Nastavením parametru <envar>AngleVariance</envar> lze toho efektu dosáhnou i v zásuvném modulu <emphasis>LSystem</emphasis>. Jde o hodnotu v procentech, která udává o kolik procent se mohou úhly maximálně změnit. Při provádění libovolné rotace želvy kolem jedné z jejich os, je pak úhel otočení vynásoben náhodnou hodnotou získanou na základě tohoto parametru. I při této náhodnosti lze nastavit náhodné semínko. Nastavením parametru <envar>AngleFluctuationSeed</envar> na stejnou hodnotu lze vytvořit vícekrát stejného jedince. Pokud tento parametr není nastaven v konfiguračním souboru ani v souboru L-systému, je jako semínko použit systémový čas.   
    </para>
  </sect1>
</chapter>
<chapter id="ch07">
  <title>Výkonnostní testy modulu LSystem</title>
  <para>
    Při implementaci zásuvného modulu byl brán ohled na optimalizaci celého procesu. Modul je navržen tak, aby bylo možné vkládání stromů i jiných rostlin <quote>za běhu</quote>. Důraz byl kladen zejména na rychlost generování slov. V přechozích kapitolách této práce se vyskytují obrázky několika vzorových modelů. Tabulka 7.1 obsahuje data naměřená při testování modulu LSystem. Pro testování byla použita následující počítačová sestava:
  </para>
  <para>
    <variablelist>
    	<varlistentry>
    		<term>CPU</term>
    		<listitem>
    			<para>Intel Core 2 Duo T9400 (2,53 GHz)</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term>Operační paměť</term>
    		<listitem>
    			<para>DDR2 PC5300 &mdash; 3072 MB</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term>Čipová sada</term>
    		<listitem>
    			<para>Mobile Intel GM965 Express</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term>Grafická karta</term>
    		<listitem>
    			<para>nVidia GeForce 9600M GT 256 MB</para>
    		</listitem>
    	</varlistentry>
    </variablelist>
  </para>
  <para>
		<table id="tab0701" frame="topbot" pgwide="1">
			<title>Výsledky testů výkonu zásuvného modulu LSystem.</title>
				<tgroup cols="9" colsep="0" rowsep="0">
				<thead>
					<row align="left">
						<entry colsep="1" align="left">Obrázek modelu</entry>
  					<entry>
              <inlineequation>
                <alt role="tex">t_1</alt>
              </inlineequation>
            </entry>
            <entry>
              <inlineequation>
                <alt role="tex">L</alt>
              </inlineequation>
            </entry>
            <entry>
              <inlineequation>
                <alt role="tex">I</alt>
              </inlineequation> 
            </entry>
            <entry>
              <inlineequation>
                <alt role="tex">M</alt>
              </inlineequation>
            </entry>
            <entry>
              <inlineequation>
                <alt role="tex">R</alt>
              </inlineequation>
            </entry>
            <entry>
              <inlineequation>
                <alt role="tex">Q</alt>
              </inlineequation>
            </entry>
            <entry>
              <inlineequation>
                <alt role="tex">t_2</alt>
              </inlineequation>
            </entry>
            <entry>
              <inlineequation>
                <alt role="tex">T</alt>
              </inlineequation>
            </entry>           
					</row>
				</thead>
				<tbody>
					<row rowsep="0">
						<entry colsep="1"><xref linkend="pic05050201"/> (a) &mdash; D0L-systém</entry>
						<entry colsep="0">0,024</entry>
						<entry colsep="0">2</entry>
						<entry colsep="0">14</entry>							
						<entry colsep="0">157002</entry>
						<entry colsep="0">4372</entry>
						<entry colsep="0">0</entry>
						<entry colsep="0">0,630</entry>
						<entry colsep="0">28419</entry>	
					</row>
					<row rowsep="0">
						<entry colsep="1"><xref linkend="pic05050201"/> (a) &mdash; 0L-systém</entry>
						<entry colsep="0">0,061</entry>
						<entry colsep="0">2</entry>
						<entry colsep="0">14</entry>							
						<entry colsep="0">157002</entry>
						<entry colsep="0">4372</entry>
						<entry colsep="0">0</entry>
						<entry colsep="0">0,628</entry>
						<entry colsep="0">28419</entry>						
					</row>
					<row rowsep="0">
						<entry colsep="1"><xref linkend="pic05050201"/> (a) &mdash; 2L-systém</entry>			
						<entry colsep="0">0,074</entry>
						<entry colsep="0">2</entry>
						<entry colsep="0">14</entry>							
						<entry colsep="0">157002</entry>
						<entry colsep="0">4372</entry>
						<entry colsep="0">0</entry>
						<entry colsep="0">0,633</entry>
						<entry colsep="0">28419</entry>							
					</row>
					<row rowsep="0">
						<entry colsep="1"><xref linkend="pic05050201"/> (d) &mdash; bez listů</entry>
						<entry colsep="0">0,053</entry>
						<entry colsep="0">1</entry>
						<entry colsep="0">25</entry>		
						<entry colsep="0">110112</entry>
						<entry colsep="0">2693</entry>
						<entry colsep="0">0</entry>
						<entry colsep="0">0,092</entry>
						<entry colsep="0">340</entry>			
					</row>
					<row rowsep="0">
						<entry colsep="1"><xref linkend="pic05050201"/> (d) &mdash; s listy</entry>
						<entry colsep="0">0,055</entry>
						<entry colsep="0">2</entry>
						<entry colsep="0">25</entry>
						<entry colsep="0">110112</entry>
						<entry colsep="0">23491</entry>
						<entry colsep="0">0</entry>
						<entry colsep="0">0,187</entry>
						<entry colsep="0">5992</entry>					
					</row>
					<row rowsep="0">
						<entry colsep="1"><xref linkend="pic05050301"/> (c)</entry>
						<entry colsep="0">0,663</entry>
						<entry colsep="0">2</entry>
						<entry colsep="0">20</entry>
						<entry colsep="0">38753</entry>
						<entry colsep="0">14157</entry>
						<entry colsep="0">2883</entry>
						<entry colsep="0">0,107</entry>
						<entry colsep="0">47486</entry>					
					</row>
					<row rowsep="0">
						<entry colsep="1"><xref linkend="pic05050301"/> (a)</entry>
						<entry colsep="0">3,083</entry>
						<entry colsep="0">2</entry>
						<entry colsep="0">90</entry>
						<entry colsep="0">785429</entry>
						<entry colsep="0">226138</entry>
						<entry colsep="0">6552</entry>
						<entry colsep="0">0,168</entry>
						<entry colsep="0">172610</entry>			
					</row>
				</tbody>
			</tgroup>
		</table>
	</para>
	<para>
    Tabulka 7.1 obsahuje kromě času zpracování i množství zpracovaných dat a počet provedených, po výkonnostní stránce důležitých, operací. Veškeré časy byly vypočteny jako průměr z pěti měření. Jednotlivé sloupce mají následující význam: 
  </para>
  <para>
    <variablelist>
    	<varlistentry>
    		<term><inlineequation>
      <alt role="tex">t_1</alt>
    </inlineequation></term>
    		<listitem>
    			<para>Udává čas potřebný pro vygenerování slova v sekundách. Jedná se tedy o nahrání a zpracování L-systému a vykonání všech iterací.</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term><inlineequation>
              <alt role="tex">L</alt>
            </inlineequation></term>
    		<listitem>
    			<para>Počet použitých L-systémů.</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term><inlineequation>
              <alt role="tex">I</alt>
            </inlineequation></term>
    		<listitem>
    			<para>Počet iterací, jež byly provedeny na hlavním L-systému.</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term><inlineequation>
              <alt role="tex">M</alt>
            </inlineequation></term>
    		<listitem>
    			<para>Celkový počet zpracovaných modulů.</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term><inlineequation>
              <alt role="tex">R</alt>
            </inlineequation></term>
    		<listitem>
    			<para>Jedná se počet aplikací přepisovacího pravidla rozdílného od identity.</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term><inlineequation>
              <alt role="tex">Q</alt>
            </inlineequation></term>
    		<listitem>
    			<para>Počet zpracovaných dotazů.</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term><inlineequation>
      <alt role="tex">t_2</alt>
    </inlineequation></term>
    		<listitem>
    			<para>Čas interpretace všech modulů a vytvoření geometrie modelu.</para>
    		</listitem>
    	</varlistentry>
    	<varlistentry>
    		<term><inlineequation>
      <alt role="tex">T</alt>
    </inlineequation></term>
    		<listitem>
    			<para>Celkový počet vytvořených želv pro dotazy i geometrii.</para>
    		</listitem>
    	</varlistentry>
    </variablelist>
  </para>
  <para>
    Výsledky z prvních tří řádků tabulky 7.1 patří k totožnému L-systému. Jedná se o jednoduchý ternární strom generovatelný i D0L-systémem. Liší se pouze použitým algoritmem pro generování. První řádek obsahuje časy při generování modelu pomocí algoritmu pro D0L-systémy. Díky optimalizaci pro tento typ má tento algoritmus nejlepší výsledek při generování slova. Tento algoritmus je také automaticky zvolen při správném nastavení parametrů typu L-systému. Druhý řádek obsahuje hodnoty při generování totožného modelu stochastickým parametrickým 0L-systémem. Hodnoty v třetím řádku pak byly získány pomocí generování algoritmem pro stochastické parametrické 2L-systémy. I když v případě tohoto modelu není rozdíl pro člověka znatelný, při generování delších a komplikovanějších slov, či většího počtu L-systému, bude volba správného, pro daný účel optimalizovaného, algoritmu důležitá. 
  </para>
  <para>
    Dalším modelem byl strom vytvořený pomocí stochastického parametrického L-systému. Čtvrtý a pátý řádek tabulky nabízí srovnání generování modelu bez listů a s listy. Tento model obsahuje ve svých pravidlech výrazy, jež jsou při každém přepisu předchůdce na následníka vyhodnocovány. Zároveň také náhodně vybírá pravidla dle podmínek, jež jsou s každým modulem předchůdce různé. Poslední dva řádky obsahují hodnoty modelů kontextových L-systémů. Prvním z nich je simulace živého plotu. Druhý pak simuluje chování stromu u překážky. Oba tyto modely využívají kromě metod zmíněných u předchozích modelů také mechanismus dotazů pro zjišťování polohy želvy.
  </para>
</chapter>

<chapter id="ch08">
  <title>Závěr</title>
  <para>
    Simulace přírody je, a v nejbližší budoucnosti nejspíš i bude, jednou z nejvíce zkoumaných oblastí počítačové grafiky. Poznat a napodobit jevy kolem nás se snaží odborníci již od počátku výpočetní techniky. Generování rostlinných organismů je pro řadu vědců velkou výzvou. Jedná se sice o geometricky složité organismy, jejich stavbu, vývoj a vlastnosti lze však často jednoduše matematicky popsat. Díky tomu se tímto tématem zabývá několik výzkumných skupin a k dispozici je vcelku velké množství literatury z oblasti počítačové grafiky i biologie.   
  </para>
  <para>
    V rámci této práce vznikl pro systém Vrecko jednoduše rozšiřitelný zásuvný modul pracující s L-systémy, jež jsou v současné době nejvíce používanou metodou pro generování rostlinných organismů. Pro vývoj tohoto modulu bylo zapotřebí nastudovat množství literatury, která se zabývá různými metodami generování slov pomocí L-systémů a vytvářením geometrie rostlinných organismů. Nutností však bylo zaměřit se i na materiály zabývající se biologickou stavbou rostlin. Při návrhu byl pak kladen velký důraz na modulárnost a zároveň optimalizaci celého jádra zásuvného modulu. Byly proto navrženy specializované a rychlé datové struktury. Většina tříd je navržena proti rozhraní a tak není problém libovolnou funkcionalitu rozšířit. Pro srozumitelnost a rozšiřitelnost kódu byla řada tříd navržena pomocí návrhových vzorů.  
  </para>
  <para>
    Zásuvný modul se skládá ze dvou samostatných celků. První z nich generuje slova pomocí uživatelsky zadaných L-systémů. Díky implementaci různých pokročilých typů L-systému, je možné vytvářet slova, jež simulují složité struktury a dodržují různé přírodní nebo i jiné zákonitosti. Výkonnostní testy ukázaly, že přepisovací proces je velice rychlý a nebrání tak ve vytváření slov v reálném čase. K většímu zpomalení nedochází ani při použití výrazů v parametrických L-systémech a náhodného výběru následníka dle zadaných kritérií. I kontextové L-systémy jsou navrženy tak, že je ověřování kontextu jednoznačné a dostatečně rychlé pro použití v reálném čase. Razantnější zpomalení přichází až s použitím dotazů. Zjišťování polohy želvy již v době generování slova je časově nejnákladnější procedurou, která však umožňuje reakci L-sytému na okolí. Díky tomu byly vytvořeny modely jež se automaticky vytvářejí a zastříhávají do parametricky definovaného tvaru. Uživatelský vstup se provádí pomocí strukturovaných XML souborů s L-systémy a jejich parametry.  
  </para>
  <para>
    Druhý samostatný celek se stará o generování geometrie pomocí želví grafiky. Je optimalizován především pro tvorbu stromů, jež byly prvotním cílem této práce. K dispozici jsou želvy, které generují geometrii kmenů, stonků i jednoduchých listů. Díky jednoduchým rozhraním je však jednoduše možné množství implementovaných typů želv rozšířit a vytvářet libovolná jiná přírodní nebo umělá geometrická tělesa. I zde je navíc implementována řada rozšiřujícch metod, které dělají modely zajímavějšími a reálnějšími. 
  </para>
  <para>
    Spojením těchto dvou částí vznikl modul, který umožňuje vytvářet velice širokou škálu modelů, které pak mohou být součástí jiných grafických scén či simulací systému Vrecko. Tato práce ukázala, jak zajímavé může generování rostlin být a snad také položila základní kámen generování rostlin v tomto interaktivním virtuálním prostředí.    
  </para>
</chapter>
 

<bibliography>
   <biblioentry>
      <abbrev>Prusin04</abbrev>
      <authorgroup>
         <author>
           <firstname>Przemyslaw</firstname>
           <surname>Prusinkiewicz</surname>
         </author>  
         <author>
           <firstname>Aristid</firstname>
           <surname>Lindenmayer</surname>
         </author>
      </authorgroup>
      <title>The Algorithmic Beauty of Plants</title>    
      <publisher>
         <publishername>Springer-Verlag</publishername>
      </publisher>
      <pubdate>1990</pubdate>
      <isbn>9780387972978</isbn>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Hanan92</abbrev>
      <authorgroup>
         <author>
           <firstname>James Scott</firstname>
           <surname>Hanan</surname>
         </author>  
      </authorgroup>
      <title>Parametric L-systems and their application to the modelling and visualisation of plants</title>    
      <publisher>
      </publisher>
      <pubdate>1992</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Bloom94</abbrev>
      <authorgroup>
         <author>
           <firstname>James Scott</firstname>
           <surname>Hanan</surname>
         </author>  
      </authorgroup>
      <title>Modeling the mighty maple</title>    
      <publisher>
         <publishername>Computer Graphics (SIGGRAPH '94 Conference Proceedings)</publishername>
      </publisher>
      <pubdate>1985</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Bell08</abbrev>
      <authorgroup>
         <author>
           <firstname>Adrian D.</firstname>
           <surname>Bell</surname>
         </author>
         <author>
           <firstname>Alan</firstname>
           <surname>Bryan</surname>
         </author>  
      </authorgroup>
      <title>Plant form: an illustrated guide to flowering plant morphology</title>    
      <publisher>
         <publishername>Timber Press</publishername>
      </publisher>
      <pubdate>2008</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Koch05</abbrev>
      <authorgroup>
         <author>
           <firstname>Helge</firstname>
           <surname>von Koch</surname>
         </author>
      </authorgroup>
      <title>Une méthode géométrique élémentaire pour l'étude de certaines questions de la théorie des courbes planes</title>    
      <publisher>
         <publishername>Acta mathematica</publishername>
      </publisher>
      <pubdate>1905</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Linden68</abbrev>
      <authorgroup>
         <author>
           <firstname>Aristid</firstname>
           <surname>Lindenmayer</surname>
         </author>
      </authorgroup>
      <title>Mathematical models for cellular interaction in development, Díl I a II</title>    
      <publisher>
         <publishername>Journal of Theoretical Biology</publishername>
      </publisher>
      <pubdate>1968</pubdate>
   </biblioentry>  
   
   <biblioentry>
      <abbrev>Holt94</abbrev>
      <authorgroup>
         <author>
           <firstname>Matthew</firstname>
           <surname>Holton</surname>
         </author>
      </authorgroup>
      <title>Strands, gravity and botanical tree imagery</title>    
      <publisher>
         <publishername>Computer Graphics Forum</publishername>
      </publisher>
      <pubdate>1994</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Rozen1980</abbrev>
      <authorgroup>
         <author>
           <firstname>Grzegorz</firstname>
           <surname>Rozenberg</surname>
         </author> 
         <author>
           <firstname>Arto</firstname>
           <surname>Saloma</surname>
         </author>
      </authorgroup>
      <title>The mathematical theory of L-systems</title>    
      <publisher>
         <publishername>Academic Press</publishername>
      </publisher>
      <pubdate>1980</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Mitch1972</abbrev>
      <authorgroup>
         <author>
           <firstname>G.J.</firstname>
           <surname>Mitchinson</surname>
         </author> 
         <author>
           <firstname>Michael</firstname>
           <surname>Wilcox</surname>
         </author>
      </authorgroup>
      <title>Rules governing cell division in Anabaena</title>    
      <publisher>
         <publishername>Nature</publishername>
      </publisher>
      <pubdate>1972</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Prusin94</abbrev>
      <authorgroup>
         <author>
           <firstname>Przemyslaw</firstname>
           <surname>Prusinkiewicz</surname>
         </author>
         <author>
           <firstname>Lila</firstname>
           <surname>Kari</surname>
         </author>
      </authorgroup>
      <title>Subapical bracketed L-systems</title>    
      <publisher>
         <publishername>Proceedings of the Fifth International Workshop on Graph Grammars and their Application to Computer Science</publishername>
      </publisher>
      <pubdate>1994</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Prusin96</abbrev>
      <authorgroup>
         <author>
           <firstname>Przemyslaw</firstname>
           <surname>Prusinkiewicz</surname>
         </author>
         <author>
           <firstname>Mark</firstname>
           <surname>Hammel</surname>
         </author>
         <author>
           <firstname>Jim</firstname>
           <surname>Hanan</surname>
         </author>
         <author>
           <firstname>Radomír</firstname>
           <surname>Měch</surname>
         </author>
      </authorgroup>
      <title>L-systems: from the Theory to Visual Models of Plants</title>    
      <publisher>
         <publishername>CSIRO Publishing</publishername>
      </publisher>
      <pubdate>1996</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Mech97</abbrev>
      <authorgroup>
         <author>
           <firstname>Radomír</firstname>
           <surname>Měch</surname>
         </author>
         <author>
           <firstname>Przemyslaw</firstname>
           <surname>Prusinkiewicz</surname>
         </author>
         <author>
           <firstname>Jim</firstname>
           <surname>Hanan</surname>
         </author>
      </authorgroup>
      <title>Extension to the graphical interpretion of L-systems based on turtle geometry</title>    
      <publisher>
         <publishername>CSIRO Publishing</publishername>
      </publisher>
      <pubdate>1997</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Zara04</abbrev>
      <authorgroup>
         <author>
           <firstname>Jiří</firstname>
           <surname>Žára</surname>
         </author>  
         <author>
           <firstname>Bedřich</firstname>
           <surname>Beneš</surname>
         </author>
         <author>
           <firstname>Jiří</firstname>
           <surname>Sochor</surname>
         </author>
         <author>
           <firstname>Petr</firstname>
           <surname>Felkel</surname>
         </author>
      </authorgroup>
      <title>Moderní počítačová grafika</title>    
      <publisher>
         <publishername>Computer Press, a.s.</publishername>
      </publisher>
      <pubdate>2004</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>Abel82</abbrev>
      <authorgroup>
         <author>
           <firstname>Harold</firstname>
           <surname>Abelson</surname>
         </author>  
         <author>
           <firstname>Andrea A.</firstname>
           <surname>DiSessa</surname>
         </author>
      </authorgroup>
      <title>Turtle geometry</title>    
      <publisher>
         <publishername>M.I.T. Press</publishername>
      </publisher>
      <pubdate>1982</pubdate>
   </biblioentry>   
   
   <biblioentry>
      <abbrev>Kele86</abbrev>
      <authorgroup>
         <author>
           <firstname>Alice</firstname>
           <surname>Kelemenová</surname>
         </author>  
      </authorgroup>
      <title>Complexity of L-systems</title>    
      <publisher>
         <publishername>Springer-Verlag</publishername>
      </publisher>
      <pubdate>1986</pubdate>
   </biblioentry> 
   <biblioentry>
      <abbrev>Deus05</abbrev>
      <authorgroup>
         <author>
           <firstname>Oliver</firstname>
           <surname>Deussen</surname>
         </author>  
         <author>
           <firstname>Bernd</firstname>
           <surname>Lintermann</surname>
         </author>  
      </authorgroup>
      <title>Digital Design of Nature: Computer Generated Plants and Organics</title>    
      <publisher>
         <publishername>Springer-Verlag</publishername>
      </publisher>
      <pubdate>2005</pubdate>
      <isbn>978-3-540-40591-7</isbn>
   </biblioentry>
</bibliography>

<appendix id="appA">
  <title>Přehled interpretovaných příkazů pro želví grafiku</title>
    <para>V interpretační fází prochází instance některého z interpretů celý zpracovávaný řetězec modulů zleva doprava. Jednotlivé moduly pak převede na příkaz buď některé z želv nebo přímo zásobníku s želvami.Tato příloha obsahuje přehled všech interpretovaných modulů, jejich identifikující znak a popis příkazu, který vykonají. Většina modulů umožňuje zadání parametru. Pokud není tento parametr zadán, použije se výchozí hodnota nastavená v konfiguraci modulu LSystem.
    </para>
    <sect1 id="secA01">
      <title>Rotace želvy</title>
      <para>
        Želva může provádět rotace pouze kolem některého ze svých bázových vektorů.  
      </para>
      <variablelist>
  			<varlistentry>
  				<term>+(α)</term>
  				<listitem>
  					<para>Změní kurs rotací kolem osy U o úhel α doleva.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>-(α)</term>
  				<listitem>
  					<para>Změní kurs rotací kolem osy U o úhel α doprava.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>&amp;(α)</term>
  				<listitem>
  					<para>Provede podélný sklon rotací kolem osy L o úhel α dolů.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>^(α)</term>
  				<listitem>
  					<para>Provede podélný sklon rotací kolem osy L o úhel α nahoru.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>\(α)</term>
  				<listitem>
  					<para>Provede příčný náklon rotací kolem osy H o úhel α doleva.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>/(α)</term>
  				<listitem>
  					<para>Provede příčný náklon rotací kolem osy H o úhel α doprava.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>|</term>
  				<listitem>
  					<para>Provede otočení do protisměru. Tento symbol odpovídá příkazu +(180) nebo -(180).</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>=</term>
  				<listitem>
  					<para>Vyrovná příčný náklon do vodorovné polohy vůči původnímu souřadnicovému systému.</para>
  				</listitem>
  			</varlistentry>
  		</variablelist>      
    </sect1>
    <sect1 id="secA02">
      <title>Změna vlastností želvy</title>
      <para>
        Tyto příkazy mění hodnoty, jež jsou použity při bezparametrickém použití modulů.
      </para>
      <variablelist>
  			<varlistentry>
  				<term>:(x)</term>
  				<listitem>
  					<para>Vynásobí hodnotu výchozího úhlu hodnotou <emphasis>x</emphasis>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>'(x)</term>
  				<listitem>
  					<para>Vynásobí hodnotu výchozí délky kroku hodnotou <emphasis>x</emphasis>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>!(x)</term>
  				<listitem>
  					<para>Vynásobí hodnotu výchozí tloušťky kreslené čáry hodnotou <emphasis>x</emphasis>.</para>
  				</listitem>
  			</varlistentry>
  		</variablelist>
    </sect1> 
    <sect1 id="secA03">
      <title>Změna pozice želvy</title>
      <para>
        Tyto příkazy posouvají želvu kupředu ve směru vektoru 
        <inlineequation>
          <alt role="tex">\vec{H}</alt>
        </inlineequation>.
      </para>
      <variablelist>
  			<varlistentry>
  				<term>F(x)</term>
  				<listitem>
  					<para>Posune želvu o délku x kupředu. Tento příkaz generuje geometrii.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>Z</term>
  				<listitem>
  					<para>Posune želvu kupředu o poloviční délku než je výchozí hodnota. Tento příkaz generuje geometrii.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>f(x)</term>
  				<listitem>
  					<para>Posune želvu o délku x kupředu. Tento příkaz negeneruje geometrii.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>z</term>
  				<listitem>
  					<para>Posune želvu kupředu o poloviční délku než je výchozí hodnota. Tento příkaz negeneruje geometrii.</para>
  				</listitem>
  			</varlistentry>
  		</variablelist>
    </sect1>   
    <sect1 id="secA04">
      <title>Operace na zásobníku želv</title>
      <para>
        Větvení a vkládání podřízených L-systémů zajišťují příkazy pro manipulaci se zásobníkem želv.
      </para>
      <variablelist>
  			<varlistentry>
  				<term> [ </term>
  				<listitem>
  					<para>Vloží na zásobník novou želvu, která sdědí parametry od želvy, jež byla na vrcholu zásobníku před ní.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term> ] </term>
  				<listitem>
  					<para>Odstraní z vrcholu zásobníku želvu.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>#{ID}</term>
  				<listitem>
  					<para>Vloží, a po interpretaci opět odstraní, želvu podřízeného L-systému. Parametr ID je unikátní identifikátor L-systému.</para>
  				</listitem>
  			</varlistentry>
        <varlistentry>
  				<term>%</term>
  				<listitem>
  					<para>Vynutí násilné ukončení větve. Odstraní všechny symboly dané větve, jež za tímto symbolem následují.</para>
  				</listitem>
  			</varlistentry>  
  		</variablelist>
    </sect1>
    <sect1 id="secA05">
      <title>Změna nastavení tropismu</title>
      <para>
        Pomocí těchto příkazů lze změnit pružnost želv.
      </para>
      <variablelist>
  			<varlistentry>
  				<term>;(x)</term>
  				<listitem>
  					<para>Vynásobí hodnotu pružnosti při diatropismu hodnotou <emphasis>x</emphasis>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>~(x)</term>
  				<listitem>
  					<para>Vynásobí hodnotu pružnosti při geotropismu hodnotou <emphasis>x</emphasis>.</para>
  				</listitem>
  			</varlistentry>
  		</variablelist>
    </sect1>
</appendix> 
<appendix id="appB">
  <title>Přehled parametrů pro nastavení L-systémů</title>
    <para>Zásuvný modul LSystem se při generování a interpretaci slova řídí celou řadou parametrů. Jejich globální nastavení nezávislé na konrétním L-systému lze provést v konfiguračním souboru. Parametry lze nastavit i pro konkrétní L-systém přímo v jeho souboru. Tato nastavení pak mají přednost před globálními.</para>
    <sect1 id="secB01">
      <title>Parametry generátoru slov</title>
      <variablelist>			
  			<varlistentry>
  				<term>Iteration</term>
  				<listitem>
  					<para>Při nastavení této hodnoty je po nahrání L-systému automaticky spuštěn iterační proces a provede se nastavený počet iterací. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>UseQueries</term>
  				<listitem>
  					<para>Povolí použití dotazů. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>Ignore</term>
  				<listitem>
  					<para>Výčet znaků, jež budou ignorovány při párování kontextu. Hodnota je řetězec znaků.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>RandomSeed</term>
  				<listitem>
  					<para>Nastaví semínko generátoru pseudonáhodných čísel. Pokud tento parametr není nastaven, použije se jako semínko systémový čas počítače. Tento parametr lze nastavit pouze v konfiguračním souboru jako globální hodnotu. V parametrech L-systému nebude mít žádný vliv. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry> 
  		</variablelist>
  	</sect1>
  	<sect1 id="secB02">
      <title>Parametry želvy</title>
      <variablelist>
  			<varlistentry>
  				<term>TurtleType</term>
  				<listitem>
  					<para>Nastaví typ želvy, která bude interpretovat slovo.</para>
  					<para>Jedná se o výčtový typ a implementovány jsou tyto tři typy:</para>
  					<variablelist>
        			<varlistentry>
        				<term>JOINTED_PIPE</term>
        				<listitem>
        				  <para>Vykresluje geometrii válců s klouby.</para>
        				</listitem>
  			      </varlistentry>
  			      <varlistentry>
        				<term>STRAIGHT_PIPE</term>
        				<listitem>
        				  <para>Vykresluje geometrii navazujících válcovitých těles.</para>
        				</listitem>
  			      </varlistentry>
  			      <varlistentry>
        				<term>RECTANGLE</term>
        				<listitem>
        				  <para>Vykresluje obdélníky. Vhodná pro jednoduché listy.</para>
        				</listitem>
  			      </varlistentry>
  			    </variablelist>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>DefaultAngle</term>
  				<listitem>
  					<para>Nastaví výchozí úhel pro veškeré rotace želvy. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>DefaultLength</term>
  				<listitem>
  					<para>Nastaví výchozí délku kroku želvy. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>DefaultRadius</term>
  				<listitem>
  					<para>Nastaví výchozí poloměr čáry, kterou želva kreslí. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>AngleMultiplier</term>
  				<listitem>
  					<para>Při bezparametrickém použití symbolu <envar>:</envar> je touto hodnotou vynásoben výchozí úhel. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>LengthMultiplier</term>
  				<listitem>
  					<para>Při bezparametrickém použití symbolu <envar>'</envar> je touto hodnotou vynásobena výchozí délka kroku. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>RadiusMultiplier</term>
  				<listitem>
  					<para>Při bezparametrickém použití symbolu <envar>!</envar> je touto hodnotou vynásoben výchozí poloměr kreslené čáry. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>DegreesToRadians</term>
  				<listitem>
  					<para>Při zadávání úhlů ve stupních musí být tato hodnota nastavena na 1.</para>
  				</listitem>
  			</varlistentry>
  		</variablelist>
  	</sect1>
  	<sect1 id="secB03">
      <title>Parametry vykreslované geometrie</title>
      <variablelist>
  			<varlistentry>
  				<term>ContourDetail</term>
  				<listitem>
  					<para>Tento parametr udává úroveň detailu vykreslované geometrie. U extrudovaných těles se jedná o počet vrcholů kontury. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>AngleVariance</term>
  				<listitem>
  					<para>Tento parametr udává maximální procentuální náhodný výkyv úhlů. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>DrawPipeCaps</term>
  				<listitem>
  					<para>Povolí vykreslování podstavy na konci válcovitých těles. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>MinimizeTwist</term>
  				<listitem>
  					<para>Povolí vyrovnávání příčného náklonu. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>SeparateGeometryForTranslucent</term>
  				<listitem>
  					<para>Vynutí vytváření uzlu pro každé vzkreslené těleso s průhlednou texturou. Lze takto odstranit halo efekt u listů za cenu snížení výkonu. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>Color</term>
  				<listitem>
  					<para>Nastaví barvu vykreslované geometrie. Při nastavení materiálů se barva neprojeví. Hodnota je vektor ve tvaru <envar>(double,double,double)</envar>.</para>
  				</listitem>
  			</varlistentry> 
  			<varlistentry>
  				<term>DiffuseMaterial</term>
  				<listitem>
  					<para>Nastaví difuzní složku materiálu geometrie. Hodnota je vektor ve tvaru <envar>(double,double,double)</envar>.</para>
  				</listitem>
  			</varlistentry>
        <varlistentry>
  				<term>SpecularMaterial</term>
  				<listitem>
  					<para>Nastaví spekulární složku materiálu geometrie. Hodnota je vektor ve tvaru <envar>(double,double,double)</envar>.</para>
  				</listitem>
  			</varlistentry> 
  			<varlistentry>
  				<term>AmbientMaterial</term>
  				<listitem>
  					<para>Nastaví ambientní složku materiálu geometrie. Hodnota je vektor ve tvaru <envar>(double,double,double)</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>DiffuseTexture</term>
  				<listitem>
  					<para>Nastaví texturu. Hodnota je cesta k souboru textury.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>TextureSRepeatings</term>
  				<listitem>
  					<para>Nastaví počet opakování textury po obvodu válcovité struktury. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  		</variablelist>
  	</sect1>
  	<sect1 id="secB04">
    	<title>Tropismus</title>
      <variablelist>
  			<varlistentry>
  				<term>GravitropismElasticity</term>
  				<listitem>
  					<para>Nastaví pružnost modelu vzhledem ke gravitropismu. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>TropismElasticity</term>
  				<listitem>
  					<para>Nastaví pružnost modelu vzhledem k diatropismu. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>TropismVector</term>
  				<listitem>
  					<para>Nastaví vektor pro diatropismus. Hodnota je vektor ve tvaru <envar>(double,double,double)</envar>.</para>
  				</listitem>
  			</varlistentry> 
  			<varlistentry>
  				<term>TropismAngle</term>
  				<listitem>
  					<para>Nastaví úhel pro diatropismus. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry> 
  		</variablelist>
  	</sect1>
  	<sect1 id="secB05">
      <title>Geometrie pro ladění</title>  
      <variablelist>
  			<varlistentry>
  				<term>DrawDebugGeometry</term>
  				<listitem>
  					<para>Povolí vykreslování geometrie pro ladění. Standardně vykresluje polohové vektory želvy při každém kroku. Hodnota je typu <envar>unsigned integer</envar>.</para>
  				</listitem>
  			</varlistentry>
  			<varlistentry>
  				<term>DebugGeometryScale</term>
  				<listitem>
  					<para>Měřítko geometrie pro ladění. Hodnota je typu <envar>double</envar>.</para>
  				</listitem>
  			</varlistentry> 
  		</variablelist>
  	</sect1> 	
</appendix>
<appendix id="appC">
  <title>Přiložené CD</title>
    <para>K této diplomové práci je přiložen kompaktní disk s následujícím obsahem:</para>
    <para>
		<itemizedlist mark="opencircle">
			<listitem><simpara>Text této diplomové práce ve formátech PDF, PS a XML.
			</simpara></listitem>
			<listitem><simpara>Veškeré použité obrázky ve formátu JPG.
			</simpara></listitem>
			<listitem><simpara>Zdrojové kódy zásuvného modulu LSystem včetně projektových souborů pro Visual Studio 2005.
			</simpara></listitem>
			<listitem><simpara>Dokumentace k zásuvnému modulu LSystem.
			</simpara></listitem>
			<listitem><simpara>Zkompilovaný zásuvný modul LSystem ve formě dynamické knihovny DLL.
			</simpara></listitem>
			<listitem><simpara>Zkompilovaná aplikace Vrecko.
			</simpara></listitem>
			<listitem><simpara>Dávkové soubory s ukázkami generování stromů pomocí zásuvného modulu LSystem v prostředí Vrecko.
			</simpara></listitem>
			<listitem><simpara>Archívy použitých knihoven Boost a FunctionParser.	
      </simpara></listitem>
		</itemizedlist>
	</para>
</appendix>
</book>