<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" 
   "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY % fithesis SYSTEM "http://www.fi.muni.cz/~xpavlov/fithesis.mod">
   %fithesis; ]>

<book lang="cs" xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">

<bookinfo>
    <title>Generování rostlin pomocí L-systémů</title>
    <subtitle>Diplomová práce</subtitle>
    <author>
        <firstname>Marek</firstname>
        <surname>Pasičnyk</surname>
        <fi:woman>false</fi:woman>
        <fi:faculty>fi</fi:faculty>
        <fi:advisor>RNDr. Vít Kovalčík, Ph.D.</fi:advisor>
    </author>
    <pubdate>jaro 2010</pubdate>
    <fi:thanks><para>Chtěl bych poděkovat 
    </para></fi:thanks>
    <abstract>
        <para>
        Tato práce se zabývá problematikou Lindenmayerových systémů, jakožto nástroje pro generování rostlin. Rozebírá pak také metody a implementaci L-systémů a jejich grafickou implementaci. Součástí je i zásuvný modul pro generování rostlin pro systém Vrecko.
        </para>
    </abstract>
    <keywordset>
   		<keyword>Lindenmayerovy systémy</keyword>
   		<keyword>L-systémy</keyword>
      <keyword>generování rostlin</keyword>
      <keyword>generování stromů</keyword>
      <keyword>Vrecko</keyword>
      <keyword>OpenSceneGraph</keyword>
      <keyword>LSystem</keyword>
    </keywordset>
</bookinfo>

<toc/>

<chapter id="ch01">
  <title>Úvod</title>
  <para>
  </para>
</chapter>

<chapter id="ch02">
  <title>Lindenmayerovy systémy</title>
  <para>
Lindenmayerovy systémy, zkráceně L-systémy, byly vytvořeny jako matematická teorie pro generování rostlin(82ABOP). Původně byl kladen důraz spíše na obecnou topologii. Byly totiž vytvořeny pro simulaci vývoje větších částí rostlin nebo buněk mnhobuněčných organismů. Geometrie, ani podrobnější detaily  v této původní teorii zahrnuty nebyly. Později se objevilo několik geometrických interpretací L-systémů, díky nimž se staly L-systémy univerzálním nástrojem pro simulaci a modelování rostlin. Ve své práci používám modelování pomocí želví grafiky.
	</para>
  <sect1 id="sec0201">
    <title>Vývoj rostlin pomocí procesu přepisování</title>
   	
		<para>
Jádro L-systémů spočívá v použití přepisovacího systému. Jedná se o opakované nahrazování modulů předchůdců pomocí sady přepisovacích pravidel jejich následovníky, přičemž všechny moduly náleží do konečné abecedy modulů. Lze tak z jednoduchého původního objektu vytvořit opakováním přepisovacího procesu komplexní model. Modulem je myšlena libovolná atomická část modelu, jež většinou reprezentuje nějakou část simulovaného modelu. Pří použití při simulaci biologických procesů se tak může jednat například o buňky nebo růyné typy rostlinných orgánů. 
    </para>
    <para>
Jedním z prvních grafických modelů, používajících přepisovací pravidla, byla Kochova křivka, případně Kochova vločka (155 ABOP). Šlo o jednoduchý bezkontextový přepisovací systém, jež obsahoval pouze jediné pravidlo, přepisující jeden grafický prvek na jiný. (OBRAZEK). Později tento model podstatně rozšířil Mandelbrot, jež přidal systémy podporující přepisování úseček o různých délkách a hlavně podporu větvených topologií.
		</para>
		<para>
Největší pozornost však byla ubírána ke studiu systémů založených na přepisování řetězců znaků. Velkým přínosem v tomto odvětví byly na konci padesátých let 20. století Chomského formální gramatiky, které využívaly princip přepisování pro popis syntaxe přirozeného jazyka. V roce 1968 pak biolog Aristid Lindenmayer představil odlišný typ mechanismu přepisujícího řetězce. Tento mechanismus byl posléze pojmenován jako L-systémy. Zásadní odlišností L-systémů od Chomského gramatik spočívá v použití přepisovacích pravidel. Zatímco v Chomského gramatikách jsou přepisovací pravidla aplikována postupně, v L-systémech jsou použity paralelně v jednom derivačním kroku na všechny symboly přepisovaného řetězce. Motivací pro tento přístup byla podobnost s biologickými procesy. Příkladem mohou být mnohobuněčné organismy, ve kterých se dělí buňky současně. Na rozdíl od přírodních pochodů vývoj L-systémů probíhá v diskrétních krocích. Kvůli reprezentaci modelů jako řetězce znaků se často místo pojmu modul používá pojem symbol.		
   	</para>
  </sect1>
  <sect1 id="sec0202">
    <title>D0L-systémy</title>
    <para>
Deterministické bezkontextové L-systémy, zkráceně D0L-systémy,jsou nejjednodušší formou L-systémů. Původní Lindenmayerovy systémy zahrnovaly právě pouze tento typ. Takovýto typ L-systém se skládá z abecedy modulů, přepisovacích pravidel a axiomu, jež slouží jako počáteční řetězec modulů. Na obrázku ( str 5 ABOP) je znázorněna simulace vývoje mnohobuněčného vlákna buněk, jež se nachází v bakterii Anabaena catenula( 99 ABOP ). Tyto řetězce jsou tvořeny dvěma typy buněk. První typ jsou mladé, kratší buňky a druhým jsou buňky starší, delší. Každá buňka má také svou polaritu polaritu, která určuje, kterým směrem bude buňka růst.
    </para>
    <para>
    Formální definice D0L-systémů podle (Roz1980 Radekk) je následující:
    <itemizedlist mark='opencircle'>
      <listitem>
        <para>
Abeceda <emphasis>V</emphasis> je konečná množina <emphasis>symbolů</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
<emphasis>Slovo</emphasis> je posloupnost symbolů nad abecedou <emphasis>V</emphasis>. Množina všech těchto posloupností se označuje jako <emphasis>V*</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Přepisovací pravidlo</emphasis> je uspořádaná dvojice 
          <inlineequation>
             <alt role="tex">(a,u)</alt>
             <graphic fileref="math020101.png"/>
          </inlineequation>
          zapsaná jako 
          <inlineequation>
             <alt role="tex">a \to u</alt>
             <graphic fileref="math020102.png"/>
          </inlineequation>          
          , kde 
          <inlineequation>
             <alt role="tex">a</alt>
             <graphic fileref="math020103.png"/>
          </inlineequation>
          je symbol náležící <emphasis>V*</emphasis> a
          <inlineequation>
             <alt role="tex">u</alt>
             <graphic fileref="math020104.png"/>
          </inlineequation>
          je slovo náležící <emphasis>V*</emphasis>. Symbol 
          <inlineequation>
             <alt role="tex">a</alt>
             <graphic fileref="math020105.png"/>
          </inlineequation>
          se nazývá <emphasis>předchůdce</emphasis> a slovo 
          <inlineequation>
            <alt role="tex">u</alt>
            <graphic fileref="math020106.png"/>
          </inlineequation>
          <emphasis>následník</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>D0L-systém</emphasis> je trojice
          <inlineequation>
             <alt role="tex">G= \langle V, \omega ,P \rangle</alt>
             <graphic fileref="math020107.png"/>
          </inlineequation>
          , kde <emphasis>V</emphasis> je abeceda,
          <inlineequation>
             <alt role="tex">\omega \in </alt>
             <graphic fileref="math020108.png"/>
          </inlineequation>
          <emphasis>V*</emphasis> je počáteční slovo, nazývané <emphasis>axiom</emphasis>, a <emphasis>P</emphasis> je množina přepisovacích pravidel takových, že pro
          <inlineequation>
             <alt role="tex">\forall a \in V: \exists p_{a} \in P</alt>
             <graphic fileref="math020109.png"/>
          </inlineequation>
           , kde
           <inlineequation>
             <alt role="tex">p_{a}</alt>
             <graphic fileref="math020110.png"/>
          </inlineequation>
          označuje přepisovací pravidlo, jehož předchůdce je modul
          <inlineequation>
             <alt role="tex">a</alt>
             <graphic fileref="math020111.png"/>
          </inlineequation>
          .
        </para>
      </listitem>
    </itemizedlist>
    Dle obecných konvencí bývá přepisovací pravidlo
    <inlineequation>
     <alt role="tex">a \to u</alt>
     <graphic fileref="math020112.png"/>
    </inlineequation>
    označováno jako odpovídající modulu a pro modul, kterému neodpovídá žádné z přepisovacích pravidel, bývá použito pravidlo identity
    <inlineequation>
     <alt role="tex">a \to a</alt>
     <graphic fileref="math020113.png"/>
    </inlineequation>
    . Modul je možné během vývoje L-systému odstranit pomocí použití
    <inlineequation>
     <alt role="tex">\epsilon</alt>
     <graphic fileref="math020114.png"/>
    </inlineequation>
    pravidla.
    </para>   
  </sect1>
  
  
  <sect1 id="sec0203">
    <title>L-systémy se závorkami</title>
    <para>
    Obecné D0L-systémy poskytují možnosti pouze pro vytvoření sekvence modulů. Aby však bylo možné vytvořit slova reprezentující rostliny, je nutné umožnit L-systémům vytvářet větvené topologie. Pro reprezentaci větvených topologií je potřeba zavést dva moduly. Tyto moduly byly již součástí původního Lindenmayerova konceptu(Lin 1968 Radekk). Pro označení začátku a konce větve se používají symboly pravé a levé hranaté závorky.
    </para>
    <para>
    Slova, vyprodukovaná derivacemi přepisovacích pravidel závorkového L-systému, se označují jako stromy. Příklad takovéto stromové struktury vytvořené závorkovým L-systémem je na obrázku (str9 fig 3.2 handbook). Strom je dle (98) slovo w nad abecedou VE = V U {[,]}, kde V je abeceda všech modulů z nichž se skládají větve. Větev je pak libovolné slovo generované L-systémem bez závorek.
    </para>
  </sect1>
  <sect1 id="sec0204">
    <title>Parametrické L-systémy</title>
    <para>  
Přepisování pravidel u 0L-systémů je bezkontextové. Při produkci následníků tedy nezáleží na modulech v okolí předchůdce. Při přepisování kontextových L-systémů však musí kromě předchůdců odpovídat také jejich sousední moduly. Tímto způsobem mohou mezi sebou jednotlivé moduly komunikovat nebo posílat ostatním modulům signály. Lze tak simulovat reakci na proudění látek rostlinou nebo informovat moduly o globálních vlastnostech celého L-systému, jako je délka stonku, počet květů, stáří apod. Moduly však takto mohou komunikovat i s okolím L-systému a získávat tak informace například o množství světla, množství živin, ročním období nebo o překážce v růstu. 

Mozna dat tri typy pouziti – kapitola 7.3 handbook
    </para>
    <para>
Existuje mnoho implementací kontextových L-systémů. Nejpoužívanější jsou 1L-systémy a 2L-systémy. U 1L-systémů je brán zřetel buď pouze na levý nebo pouze na pravý kontext modulu předchůdce. Zápis pravidel s jednostranným kontextem tedy může být ve tvaru
      <quote><emphasis>lk &lt; předchůdce 
      <inlineequation>
        <alt role="tex">\to</alt>
        <graphic fileref="math020401.png"/>
      </inlineequation>
      následník
      </emphasis></quote>
      nebo
      <quote><emphasis>předchůdce > pk
      <inlineequation>
        <alt role="tex">\to</alt>
        <graphic fileref="math020402.png"/>
      </inlineequation>
      následník
      </emphasis></quote>
    </para>
, kde <emphasis>lk</emphasis> je levý a <emphasis>pk</emphasis> pravý kontext. Následující L-systém ukazuje, jakým způsobem je možné propagovat signál. 
  </sect1>
</chapter>


<chapter id="ch03">
  <title>Modelování rostlinných organismů</title>
  <para>
  </para>
  <sect1 id="sec0301">
    <title>Interpretace želví grafikou</title>
    <para>
Protože byly L-systémy navrženy jako matematický model bez geometrické interpretace, je potřeba pro modelování rostlin použít některý z přístupů, jež pro tento účel byly buď vyvinuty nebo byly převzaty. Sám Lindenmayer publikoval v roce 1974 řešení jež nahrazovalo moduly řetězců grafickými obrazci. Šlo však hlavně o topologii větvení rostlin a detaily jako délky nebo úhly natočení segmentů byly do modelu dodávány dodatečně. Během sedmdesátých a osmdesátých let vzniklo ještě mnoho jiných interpretací L-systémů, jež například ukázaly, že L-systému jsou velmi platným nástrojem pro tvorbu fraktálů. V roce 1986 přišel Przemyslaw Prusinkiewicz s myšlenkou interpretovat L-systémy jako pohyb želvy známé z programovacího jazyka LOGO(1 ABOP). Tato želva funguje jako kurzor, který přijímá různé rozkazy týkající se jeho pohybu. Na základě těchto rozkazů pak tento kurzor kreslí svým pohybem jednu spojitou čáru(???). Použití želví grafiky značně rozšiřuje geometrické možnosti L-systémů a je ideální pro tvorbu biologických struktur. 
    </para>
    <sect2 id="sec030101">
      <title>Planární želví grafika</title>
      <para>
        Neboť původ želví grafiky spočívá v pohybu kurzoru po obrazovce, její původní koncept zahrnoval pohyb ve dvojrozměrném prostředí. Želva je definovaná jako trojice parametrů <emphasis>(x,y,α)</emphasis>, kde <emphasis>x</emphasis> a <emphasis>y</emphasis> udávají kartézké souřadnice želvy a úhel <emphasis>α</emphasis> směr, kterým želva míří, tzv. čelo. Pokud zavedeme navíc hodnotu pro délku kroku a výchozí přírůstek úhlu o který se želva bude otáčet, můžeme vytvořit jednoduchá pravidla pro pohyb želvy v rovině. Jednotlivé znaky pak reprezentují daný modul a také akci která je při načtení tohoto modulu provedena.
      </para>
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara><emphasis role="bold">F</emphasis> &mdash; Želva provede krok vpřed o předem definované délce na pozici <emphasis>(x',y')</emphasis>. Mezi body <emphasis>(x,y)</emphasis> a <emphasis>(x',y')</emphasis> je vykreslena úsečka.
            </simpara>
          </listitem>
          <listitem>
            <simpara><emphasis role="bold">+</emphasis> &mdash; Přikáže želvě otočit se o předem definovaný přírůstek úhlu doleva. Úhel želvy se zvětší o tuto hodnotu.
            </simpara>
          </listitem>
          <listitem>
            <simpara><emphasis role="bold">-</emphasis> &mdash; Přikáže želvě otočit se o předem definovaný přírůstek úhlu doprava. Úhel želvy se zmenší o tuto hodnotu.
            </simpara>
          </listitem>
        </itemizedlist>
      </para>
      <para>
Při generování grafiky pak želva s počátečními parametry (x0,y0, α0) interpretuje jednotlivé znaky řetězce postupně zleva doprava.
      </para>
    </sect2>
    <sect2 id="sec030102">
      <title>Interpretace závorkových L-systémů</title>
      <para>
        Jak již bylo výše zmíněno, pro simulaci větvících se struktur rostlin je nutné rozšíření L-systémů o závorky. Každý podřetězec uzavřený závorkami zleva i zprava představuje v topologii rostliny jednu větev. Při použití želví grafiky je tak nutné v bodech větvení rozdělit souvislou čáru, jež želva kreslí, na minimálně dvě nové cesty. Pro tyto ůčely se užívá zásobníku. Pokud želva narazí při procházení slova na znak '[', uloží se spolu se svými parametry na zásobník a její kopie pokračuje v interpretaci řetězce za závorkou. Naopak pokud želva narazí na znak ']', je odstraněna a v interpretaci pokračuje želva z vrcholu zásobníku.  
      </para>
    </sect2>
    <sect2 id="sec030103">
      <title>Rozšíření pro interpretaci L-systémů v 3D</title>
      <para>
        Jednou z hlavních výhod želví grafiky je její jednoduchá rozšiřitelnost pro použítí ve třech rozměrech. Parametry želvy však musejí být rozšířeny. Pro pozici želvy se se definuje vektor P. Pro určení orientace pak tři jednotkové vektory H, L, U takové, že splňují rozvici H x L = U. Vektor H pododbně jako u rovinné želvy udává kam želva směřuje, tedy čelo. Vektor U směřuje směrem nahoru a vektor L pak směřuje vlevo od želvy.
      </para>
      <para>
        Sada příkazů je v 3D také značně rozšířena. Pro změnu orientace želva interpretuje příkazy, jež želvu rotují okolo jednotlivých os. Pro tyto rotace jsou běžně používány termíny z letectví: směr, podélný sklon a příčný náklon. Kompletní sada příkazů, kterou intepretuje i zásuvný modul, jež byl vytvořen v rámci této práce, je i spolu s popisem iterpretovaných funkcí uvedena v příloze ???  
      </para>
    </sect2>    
  </sect1>
  <sect1 id="sec0302">
    <title>Subapikální L-systémy</title>
    <para>
      Závorkové L-systémy umožnují vytvářet velice širokou škálu řetězců. Ne všechny však odpovídají rostlinné stavbě a pro generování rostlin se tak nehodí. Zavádějí se proto jistá omezení a pravidla, obvykle nazýváné jako vzory větvení, jež nám zaručí respektování některých přírodních vlastností. Výsledkem pak jsou L-systémy, které pravdivěji odpovídají reálným rostlinám. Jednou z těchto podmnožin jsou i subapikální L-systémy. Poprvé byly představeny Kelemenovou v roce 1987(7 apical). Myšlenkou těchto L-systémů je, že k větvení dochází pouze u vrcholů již exitujících větví. Tato vlastnost výchází ze základních výsledků při pozorování rostoucích rostlin. Nové rostlinné orgány, jako je stonek, větve, listy nebo květy mohou být vytvořeny pouze z apikálního meristému. Tato tkáň obsahuje aktivně se dělicí buňky a nachází se v oblasti vrcholů větví.
    </para>
    <para>
V přírodě rozeznáváme tři typy vzorů větvení jež splňují podmínku subapikálních L-systémů. Jednoduché bazitonické a složitější mezotonické a akrotonické vzory.  
    </para>
    <sect2 id="sec030201">
      <title>Bazitonický vzor větvení</title>
      <para>
         Jedná se o struktury v nichž je větvení u vrcholu rostliny méně vyvinuté než větve blíže základny rostliny. Bazitonické struktury lze vytvořit i za pomocí jednoduchých D0L-systémů. Klasic
      </para>
    </sect2>
    <sect2 id="sec030202">
      <title>Mezotonický a Akrotonický vzor větvení </title>
      <para>

      </para>
    </sect2>
  </sect1>  
</chapter>

<chapter id="ch04">
  <title>Zásuvný modul LSystem</title>
  <para>
    Stěžejní části této diplomové práce je návrh a implemtace zásuvného modulu pro systém VRECKO. Tento modul umožnuje simulaci rostlin, stromů ale i jiných struktur pomocí různých typů L-systémů a jejich následnou grafickou interpretaci a zobrazení v systému Vrecko. Návrh a analýza byla provedena s velkým důrazem na modularitu a tedy možnost pozdějšího rozšíření o nové funkcionality.
  </para>
  <para>
    Logicky lze zásuvný modul Lsystem rozdělit na tři části. První celek tvoří syntaktický analyzátor souborů L-systémů a generátor slov. Syntaktický analyzátor zajišťuje správné zpracování L-systémů, jejich náhrání ze souboru a načtení všech potřebných parametrů. Následně pak zpracuje načtená data, která generátor použije pro provedení jednotlivých derivačních kroků L-systémů. Slova i ostatní data jsou během derivačního procesu i poté uložena do datových struktur optimalizovaných pro daný účel. Jelikož existuje několik typů L-systémů, je implementována funckionalita, která pro přepisování vybere algoritmus, který je svými schopnostmi i časovou náročností nejvhodnější pro zpracovávaný L-systém. Tvorba L-systémů se složitější strukturou se většinou neobejde bez hiearchického rozdělení problému. Zásuvný modul proto umožňuje rozdělit model na několik úrovní a do hlavního L-systému vkládat podsystémy. V praxi to pak například u generování stromů znamená, že je možné vytvořit rozdílný L-systémy pro listy, květy a plody a následně je vložit do L-systému kostry stromu. Podrobněji se touto části funcionality zabývá kapitola ???.
  </para>
  <para>
    Druhý celek se zabývá grafickou interpretací vygenerovaného řetězce. Komunikace s prvně zmiňovaným celkem je pouze na úrovni předání vygenerovaného slova, poskytnutí detailních parametrů pro nastavení interpretu a také mechanismu pro zpracování dotazů. Interpret v současné podobě používá pro generování geometrie modelů výhradně želví grafiku. Tento modul však obsahuje i interpret, jež k vytváření geometrie neslouží. Jedná se o intepret pro zpracování dotazů během generování iterací L-systémů. Je tedy optimalizován pro rychlé zjištění polohy a orientace želvy. Pro zpracování slov obsahující závorky má interpret implementován zásobník. Uživatel má také možnost zvolit si z několika typů želv, jež pak dovolují vykreslovat geometrii rozdílnými přístupy. Poslední celek plní funkci řídícího modulu a  je umístněn nad oběmi předcházejícími celky, jež spravuje. Umožňuje také nahrání a ukládání vygenerovaných slov. Odpadá tak opětovné generování při jejich dalším použití. Zároveň sprostředkovává komunikaci jak se systémem Vrecko tak mezi moduly navzájem. Jedná se především o načtení základních parametrů, které oba moduly potřebují pro svou inicializaci. 
  </para>
  <sect1 id="sec0401">
    <title>Vývoj zásuvného modulu</title>
    <para>
      Vývoj probíhal na platformě Windows v prostředí Visual Studio 2010 v jazyce C++. Veškeré třídy náleží do jmenného prostoru AP_LSystem. Stejně jako celý systém Vrecko je i modul LSystem postaven na OpenSceneGraphu. Zejména se jedná o část zajišťující interpretaci L-systémů a generování geometrie. Mimoto byly pro vývoj použity některé z knihoven Boost. Jednak jde o knihovnu Program properties pro jednoduché a intuitivní ukládání a zpracovaní nastavení a konfiguračních souborů a dále pak o knihovnu Lexical cast, která jednoduše převádí a přetypovává řetězce znaků. O zpracování XML souborů se stará knihovna Xerces-C.
    </para>
  </sect1>
  
  <sect1 id="sec0402">
    <title>OpenSceneGraph</title>
    <para>
      Základním kamenem pro modul LSystem i pro systém Vrecko je OpenSceneGraph API. Jedná se o obejktově orientované rozhraní nad OpenGL. Nízkoúrovňová funkcionalita je zde převedena na objekty v grafech scén. Zároveň jsou možnosti OpenSceneGraphu oproti klasickému OpenGL značně rozšířené a je přidáno mnoho funkcionalit, jež zjednodušují a urychlují práci programátora. 
    </para>
  </sect1>
  <sect1 id="sec0403">
    <title>Vrecko</title>
    <para>
      Jak již bylo zmíněno, je modul LSystem určen pro systém Vrecko. Jedná se o prostředí pro tvorbu virtuální reality vyvíjené v rámci HCI laboratoře na Fakultě informatiky Masarykovy univerzity v Brně. Slouží primárně pro vytváření scén, jež nějakým způsobem demonstrují a zkoumají možnosti interakce člověka s počítačem. Vychází z principu OpenSceneGraph a scény jsou tedy obdobně definovány jako grafy. Scény se v tomto prostředí dělí na objekty jež mají určité vlastnosti a dovednosti. Díky ním lze objekty ovládat a měnit jejich tvar i vlastnosti. Zároveň lze k tomuto systému připojit řadu různých zařízení pro interakci obsahu scény s uživatelem. 
    </para>
  </sect1>
</chapter>
<chapter id="ch05">
  <title>Generovaní slov pro modely rostlin</title>
  <para>
    Tato kapitola se zabývá implementací syntaktického analyzátoru a následným generováním slov pomocí L-systémů. Při implementaci této části byl kladen velký důraz na rychlost a také na modularitu. Rychlost je zde důležitá zejména při iteračním procesu, neboť výsledné slovo může mít délku až v řádu miliónů modulů. Je tedy třeba zajistit vhodné struktury pro ukládání dat a vybrat vhodný algoritmus pro rychlý přepis pravidel. Modularita a rozšířitelnost zde s rychlostí úzce souvisí. Jednotlivé typy L-systémy totiž vyžadují rozdílné přístupy při přepisování pravidel a tak je důležité vytvořit více algoritmů jež budou různé typy jednodušších i komplexnějších L-systémů zpracovávat Zároveň je však třeba zaručit, aby jednodušší L-systémy nebyly zpracovány příliš složitými algoritmy, ale aby byly vybrány jednodušší a hlavně optimalizovanější postupy pro daný problém. Modularita je zde dýležitá i pro syntaktický analyzátor jež tak zvládne zpracovat více formátů L-systémů.
  </para>
  <para>
    Celou tuto funkcionalitu a komunikaci s okolím zajišťuje třída LSystemGenerator. Tato třída je potomkem třídy AbstractGenerator jež obsahuje rozhraní pro obsluhu této třídy. Instance třídy LSystemGenerator obsahuje odkaz na hlavní L-systém třídy AbstractLSystem, který je poté použit pro generování slova. Hlavním úkolem třídy LSystemGenerator je vybrat správný syntaktický analyzátor pro nahrání souboru s L-systémem a na základě získaných parametrů vybrat a vytvořit instanci třídy dědící z AbstractLSystem, jež bude pro následný iterační proces nejvhodnější. Nahráním souborů a jejich strukturou se zabývá následující kapitola.
  </para>
  <sect1 id="sec0501">
    <title>Soubory L-systémů</title>
    <para>
      Vstupním bodem pro každý L-systém je jeho definice uložená v jednom z podporovaných souborových formátů. Spolu s definicí může být součástí celá řada parametrů, které mohou ovlivnit jak proces přepisování pravidel tak i způsob následné geometrické intepretace. Zásuvný modul nyní podporuje dva typy souborů a lze jej rozšířit o podporu dalších formátů. Jednat se jedná o mírně pozměněný textový formát LS, jež v obdobné formě používá ve svých projektech výzkumná skupina Biologického Modelování a Vizualizace kolem prof. Przemyslawa Prusinkiewicze z University of Calgary. Tento formát byl zvolen z důvodu vedoucí úlohy této skupiny v oboru L-systémů. Druhým formátem je soubor napsaný ve značkovacím jazyce XML, jež byl zvolen pro svou jednoduchou rozšířitelnost a přehlednost.
    </para>
    <para>
      Struktura je v obou případech hiearchická a a popis jejich entit je následující.  
      <itemizedlist mark='opencircle'>
        <listitem>
          <simpara><emphasis role="bold">Unikátní identifikátor L-systému</emphasis> je nutné přiřadit každému L-systému. Ten se pak používá hlavně při vkládání subsytémů nebo pro získávání parametrů o daném L-systému.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Typ L-systému</emphasis> je důležitým a nutným parametrem L-systému. Určuje základní vlastnosti jako je determiničnost a bezkontextovost L-systému. Na jeho správném nastavení pak záleží při výběru správného algoritmu pro zpracování samotných pravidel a pro následný iterační proces.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Parametry</emphasis> nastavené přímo v souboru L-systému jsou specifické pro konkrétní L-systém. Pokud některé z parametrů nejsou nastaveny zde, použijí se pro generování i interpretaci slova globální parametry získané z konfiguračního souboru. Kompletní popis jednotlivých parametrů se nachází v APPENDIX
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Subsystémy</emphasis> lze vkládát do každého L-systému. Lze je vložit přidáním cesty k souboru L-systému. Nikdy však není vhodné tvořit v grafu hiarchie L-systémů kružnice. Podrobněji se touto tématikou zabývá kapitola SUBSYSTEMY
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Axiom</emphasis> je počáteční řetězec symbolů. Jde tedy o slovo v nulté iteraci L-systému.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Přepisovací pravidla</emphasis> jsou množina, která budou použita při iteračním procesu. Na pořadí není brán zřetel, protože se při každém iteračním kroku aplikují všechny pravidla najednou. Z tohoto důvodu je však důležité, aby byla jednotlivá pravidla jednoznačná a neexistovaly dvě pravidla pro stejný modul předchůdce. Jedinou výjímkou jsou stachistické systémy. Struktura pravidel je závislá na jejich typu a podrobněji je popsána v odpovídajících podkapitolách kapitoly TYPY.
          </simpara>
        </listitem>
        <listitem>
          <simpara><emphasis role="bold">Homomorfismy</emphasis> jsou zvláštním typem přepisovacích pravidel, jež se nezpracovávají během iteračního procesu. K přepisu těchto pravidel dochází vždy až po dokončení všech iterací.
          </simpara>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Formáty se implementují jako potomci třídy AbstractFile. Ta poskytuje rozhraní pro získání potřebných dat ze souboru.   
    </para>
    <para>
        <programlisting><![CDATA[
class AbstractFile
{
protected:
    unsigned m_Type;
    std::string m_Name, m_Axiom;
    std::vector<std::string> m_Rules, m_Homomorphisms, m_Subsytems;
    void substitute(std::map<std::string, std::string> & pairs)
public:
    AbstractFile();
    virtual void open( std::string & ) = 0;
    virtual std::vector<string> * getHomomorphisms()
    virtual std::vector<string> * getRules();
    virtual std::vector<string> * getSubsystems();
    std::string & getAxiom();
    unsigned getType();
    std::string & getName();
};
  			]]></programlisting>
    </para>
    <para>
      Třídy odvozené od třídy AbstractFile musí implementovat metodu <envar>open()</envar>, jež zaručí zpracování dat ze souboru a uloží je do jednotlivých atributů této třídy. Metoda <envar>substitute()</envar> slouží jako výpomocná metoda při nahrazování řetězců a může být použita pro zpracování konstant nebo subsystémů. Ostatní metody slouží jen přístupové metody k atributům. 
    </para>
    <sect2 id="sec050101">
      <title>Formát LS</title>
      <para>
        Jedná se o jednoduchý textový formát založený na příkazech jež jsou podobné preprocesorovým příkazům jazyka C. Některé příkazy jsou párové a musí být ukončeny. Jako hodnota je brán řetězec následující po příkazu. Tento řetězec nemůže obsahovat žádné bílé znaky. Formát LS dovoluje také vkládat komentáře použitím dvojitého lomítka "//".  
      </para>
    </sect2>
    
    <sect2 id="sec050102">
      <title>Formát XML</title>
      <para>
        V případě XML souboru jde o klasický XML dokument verze 1.0 s kódováním UTF-8. Veškeré použité elementy jsou párové a nejsou použity žádné atributy. Kořenovou značkou je LSystem a ta pak obsahuje všechny potřebné entity. V následujícím odstavci je příklad zápisu L-systému do XML souboru.  
      </para>
      <para>
        <programlisting><![CDATA[
<?xml version="1.0"?>
<!-- kořenová značka -->
<LSystem>
  <!-- unikátní identifikátor L-systému -->
  <Name>TernaryTree</Name>
  <!-- typ L-systému -->
  <Types>
    <Type>0L</Type>
  </Types>
  <!-- konstanty -->
  <Constants>
    <LeafPitch>65.0</LeafPitch>
  </Constants>
  <!-- parametry -->
  <Parameters>
    <Iteration>14</Iteration>
    <TurtleType>STRAIGHT_PIPE</TurtleType>
    <DefaultAngle>30.0</DefaultAngle>
  </Parameters>
  <!-- subsystémy -->
  <Subsystems>
    <Subsystem>data\ls\leaf01.ls</Subsystem>
  </Subsystems>
  <!-- axiom -->
  <Axiom>F'(0.65)A</Axiom>
  <!-- přepisovací pravidla -->
  <Rules>
    <Rule>A:*->!(0.577)'(0.87)[/(90.74)B][/(-132.63)B]B</Rule>
    <Rule>B:*->^(33.95)[^(LeafPitch)#{Leaf01}][#{Leaf01}]Z
                       [^(LeafPitch)#{Leaf01}][#{Leaf01}]ZA</Rule>
  </Rules>
  <!-- homomorfismy -->
  <Homomorphisms>
    <Homomorphism>A:*->Z</Homomorphism>
  </Homomorphisms>
</LSystem>
			]]></programlisting>
      </para>
      <para>
        Některé symboly pravidel jsou bohužel zároveň řídícími symboly XML a tak je zapotřebí nahradit je odpovídajícími XML entitami.
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0502">
    <title>Soubory L-systémů</title>
    <para>
      Při generování slova L-systémem dochází k vytváření velmi dlouhých řetězců s nestejnorodými daty. Moduly, ze kterých se řetězce tvoří, totiž kromě znaku pro identifikaci modulu obsahují také parametry různých datových formátů. Zpracování takovýchto dat musí být navíc dostatečně rychlé. Pro tento účel byla proto vytvořena na míru přizpůsobená třída LongString. Data jsou zde uložena ve formátu, který umožňuje rychlou manipulaci s daty, především pak připojení nového řetězce na konec stávajícího. Rychlost provedení této operace je potřeba při iteračním procesu. Ten při každém kroku zpracovává původní slovo a vytváří podle něj na základě přepisovacích pravidel nové slovo další iterace. Provádí to tak, že nahlíží na jednotlivé moduly původního slova zleva doprava a hledá shodu s některým z předchůdců v přepisovacích pravidlech. V případě nalezení pravidla je následník přidán na konec nového slova. V případě, že předchůdce mezi pravidly nalezen není, připojí se na konec kopie původního modulu. Použije se tedy pravidlo identity. Implementací se zabývá kapitola LINK  
    </para>
    <sect2 id="sec050201">
      <title>Vnitřní struktura řetězce</title> 
      <para>
        Datová struktura LongString je v jádru tvořena bajtovým polem. Toto pole se nezvětšuje při každém zvětšení řetězce, ale jen vždy po dosažení určité velikosti. Dochází tak ke znatelné úspoře času při alokaci paměti, která se provádí podstatně méně častěji. Každý modul je zde uložen jako znak identifikující daný modul a případně jeho parametry. Parametry mohou být typu int, unsigned char nebo typu double. Implementace dalších typů je možná a jednoduchá. Pro současné použití však nebyly jiné typy zapotřebí. Obrázek LINK ukazuje jakým je způsobem je struktura navržena. 
      </para>
      <para>
        Jedno políčko odpovídá jednomu bajtu. Každý modul obsahuje jeden znak, jenž jej identifikuje. Dále pak může obsahovat libovolný počet parametrů. Každý parametr je identifikován dvěma bajty zleva a zprava. Při použití této datové struktury tedy není nutné provádět jakékoli převody mezi typy, jejichž hodnoty jsou tak rychle dostupné. Pro ilustraci byly na obrázku použity u jednoho modulu dva různé datové typy. Současná implementace umožňuje pouze použití modulů, které mají všechny parametry shodného typu.
      </para>
    </sect2>
    <sect2 id="sec050202">
      <title>Inicializace</title>
      <para>
        Pro vytvoření instance slouží jediný konstruktor. Jediným parametrem je velikost řetězce. Implicitní hodnota tohoto parametru je 1 048 576 bajtů. Právě hodnota tohoto parametru je také použita jako minimální přírůstek alokované paměti, pokud se stávající paměť naplní. Plnění daty lze provádět buď připojováním řetězců, jež je popsáno v následující kapitole, nebo konverzí klasického zápisu řetězce typu std::string do podoby řetězce LongString. K tomu slouží metoda convertFromString(). Této možnosti lze využít při načítání pravidel získaných ze souboru. Příklad takovéhoto řetězce:
      </para>
      <para>
        Identifikující znaky modulů jsou v nezměněné podobě uloženy i v řetězci LongString. Hodnoty parametrů jsou však konvertovány do odpovídajícího typu. Pro rozlišení typů se používají různé závorky. Zatímco kulaté závorky indikují typ double, složené závorky indikují typ integer. Konvertované hodnoty jsou v řetězci z obou stran obaleny jednobajtovým identifikátorem. Hodnota tohoto idetifikátoru odpovídá pořadí ve výčtu ParameterType.  
      </para>
    </sect2>
    <sect2 id="sec050203">
      <title>Připojování řetězců</title>
      <para>
        Jak již bylo výše zmíněno, je tato struktura optimalizována pro opakované zvětšování přidáváním řetězců na její konec. Při každém připojení se provádí kontrola, zda je alokované místo dostatečné pro připojení dalších dat. Pokud ne, volá se automaticky metoda resize(), jež alokuje novou paměť a zvětší tento řetězec o délku nastavenou při vytváření instance.
      </para>
      <para>
        Pro připojení dat je k dispozici několik metod. Jedná se o různé formy metody append(). Ta poskytuje díky šabloně možnost uložit libovolný, ve výčtu ParameterType definovaný, datový typ. Kromě toho je tato metoda přetížena kvůli specifickým způsobům připojení některých dat. Lze tak připojit jiný řetězec typu LongString nebo pole bajtů ve správném formátu.
      </para>
    </sect2>
    <sect2 id="sec050204">
      <title>Připojování řetězců</title>
      <para>
        Přistupovat lze k datům jedním ze čtyř způsobů. 
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara>Pomocí operátoru [] získat přímo hodnotu bajtu na určité pozici řetězce. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Díky metodě getData() lze získat blok dat nebo celý řetězec bajtů. Hodí se především při provádění substitucí. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Nejpoužívanější možností je metoda getSymbol(), díky níž lze získat blok dat odpovídající jednomu modulu, neboli symbolu, na dané pozici. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Pro zpracování parametrických L-systémů se používá jedna z metod šablony getParameters(), která vrací pole parametrů libovolného typu a jejich počet. Tyto parametry jsou získány z pozice za identifikujícím znakem. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Metody matchRight() a matchLeft() slouží především k ověřování kontextu. Pro svou funkci využívají metody peekSymbol() pro nahlédnutí na levý nebo pravý nejbližší znak a jelikož řetězce obsahují i závorky, jsou implementovány i pomocné metody findMatchingRightBracket() a findMatchingLeftBracket() pro nalezení odpovídajícího protějšku k nalezené závorce. Podrobněji je celá funkcionalita nalezení kontextu popsána v kapitole LINK.
            </simpara>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1> 
  <sect1 id="sec0503">
    <title>Implementace přepisovacích pravidel</title>
    <para>
      Potomci třídy AbstractFile zajišťují, aby byla pravidla správně načtena ze souboru. L-systému jsou předána jako klasický řetězec znaků. Ten však není vhodný pro samotný iterační proces. Proto se každé pravidlo zpracovává do struktury Rule. Různé typy L-systémů zpracovávají předané řetězce odlišně. Podrobněji se tomuto věnuje kapitola LINK. V této části jsou uvedeny implementační podrobnosti struktury Rule do nichž všechny L-systémy svá přepisovací pravidla před iteračním procesem ukládají.  
    </para>
    <para>
      Jednou ze zásadních věcí bylo zkomponovat do pravidel nějaký mechanismus pro vyhodnocování výrazů. V pravidlech se totiž mohou výrazy vyskytovat hned na několika místech.  
      <itemizedlist mark='opencircle'>
        <listitem>
          <simpara>Každý modul na straně následníka může místo parametru obsahovat výraz, jež se vyhodnocuje až na základě parametrů předchůdce 
          </simpara>
          <simpara>U parametrických L-systémů se může vyskytnout podmínka přepisu, která se musí před každým přepisem vyhodnotit. Při jejím nesplnění je pravidlo zamítnuto. 
          </simpara>
          <simpara>Stochastické L-systémy mívají nastaven pravděpodobnostní faktor, na jejímž základě závisí pravděpodobnost vybrání daného pravidla pro přepis. Tento faktor se může rovněž vyhodnocovat z výrazu.
          </simpara>
        </listitem>
      </itemizedlist> 
    </para>
    <para>
      Pro zpracování výrazů byla vybrána knihovna FunctionParser. Jedná se o volně dostupnou knhovnu, která poskytuje dostatečnou a navíc uživatelsky rozšíritelnou  funkcionalitu. Nabízí i možnosti optimalizace. Pro každý výraz je tedy vytvořena instance třídy FunctionParser. Pro zpracování slouží metoda <envar>Parse()</envar> s parametry zpracovávaného  výrazu a řetězce všech proměnných. Vyhodnocení se provádí metodou Eval(), která po předání pole s hodnotami proměnných vrací výsledek výrazu.
    </para>
    <para>
      Jako příklad je zde uvedeno pravidlo stochastického parametrického 2L-systému, kterým se zabývala kapitola LINK.  
    </para>
    <para>
      <programlisting><![CDATA[
A(x,y) < B(z) > C(a,b,c) : (x + z > abs(a-c)) -> B(b-1)FA(x/2,y/2) : max(0, 1-1/z*z)
   ]]></programlisting>
    </para>
    <para>
      Z tohoto zápisu je zřejmé že pro všechny výrazy se používají pouze proměnné předchůdce a kontextů. V tomto případě se jedná o x, y, z, a, b, c. Tyto znaky jsou uloženy ve struktuře Rule jako m_Variables a slouží k vytváření instancí třídy FunctionParser. Dále struktura obsahuje proměnné pro uložení znaků přechůdce, obou kontextů a odkazy na instance pro vyhodnocení podmínky pravidla a pravděpodobnostního faktoru.
    </para>
    <para>
Jelikož se následník skládá z klasických řetězců a výrazů, je jeho zpracování složitější. Jednoduché řetězce jsou uloženy do instancí třídy StaticString. Jedná se o zjednodušenou variantu třídy LongString. Data jsou zde uložena ve stejné podobě. Rozdílem však je, že tento řetězec nelze zvětšit. Pro účel krátkých neměnných řetězců následníka je tedy ideální protože paměťově nezabírá tolik prostoru jako LongString. Řetězce i výrazy se ukládájí do konejneru typu std::vector. Jsou zde uloženy tak, aby mohly být při přepisu tohoto pravidla střídavě z kontejneru vybírány. Ukázka zpracovaného pravidla z předchozího příkladu je na obrázku LINK  
    </para>
    <para>
      Z příkladu je vidět, že pokud po sobě následují dva výrazy, může být řetězec mezi nimi prázdný. Šedě jsou znázorněny znaky, které jsou zahozeny, neboť nejsou pro další zpracování potřebné.Při zpracování i následném přepisu pravidla se vždy začíná a končí. Velikost kontejneru s řetězci je tedy vždy o jednu větší než kontejner s výrazy. Je to z toho důvodu, že často existují pravidla, která obsahují v následníkovi pouze řetězec a žádný výraz.
    </para>
  </sect1>
  <sect1 id="sec0504">
    <title>Zpracování L-systémů</title>
    <para>
      Všechny tyto typy jsou implementovány jako potomci třídy AbstractLSystem. Obrázek LINK ukazuje hiearchii tříd L-systémů.
    </para>
    <para>
      Abstraktní třída AbstractLSystem obsahuje několik metod, sloužící jako rozhraní pro L-systémy. 
      <itemizedlist mark='opencircle'>
        <listitem>
          <simpara>Pro inicializaci slouží metoda loadFromFile(), která načte všechna potřebná nastavení. Jako zdroj nastavení slouží některá z instancí potomků abstraktní třídy AbstractFile. 
          </simpara>
          <simpara>Pro provedení další iterace slouží metoda nextIteration(). Počet iterací lze ovlivnit i nastavení v konfiguračním souboru a v parametrech L-systému. Díky této metodě je však možné interaktivně provádět další iterace L-systému. 
          </simpara>
          <simpara>Metoda translate() vrátí vygenerované slovo. Slovo je vždy uvnitř třídy L-systému uloženo ve své nejvyšší iteraci. Na slově, které vrací tato metoda jsou provedeny navíc finální úpravy. Jedná se o aplikaci pravidel homomorfismů a vložení slov, jež generují subystémy tohoto L-systému.
          </simpara>
        </listitem>
      </itemizedlist>   
      Veškerá funcionalita, jež je společná pro všechny typy L-systémů je implementována ve společném rodiči LSystem. Veškeré funkce se dají rozdělit do tří fází.
    </para>
    <sect2 id="sec050401">
      <title>Výběr nejvhodnějšího L-systému</title>
      <para>
        Zásuvný modul v současné podobě obsahuje tři různé třídy zpracovávající různé typy L-systémů. Liší se rychlostí a svými schopnostmi. Je tedy nutné, aby generátor vybral vhodný algoritmus. Stejně důležitý je i výběr u sybsystémů. Každý soubor L-systému má nastaven svůj typ. Jedná se o výčet vlastností, které od třídy L-systému bude požadovat. Samotné třídy mají pak implementovanou statickou metodu bool isCapable(), na základě níž lze rozpoznat zda daná třída požadavkům vyhovuje. Používá k tomu statického atributu capabilities, neboť zde jsou schopnosti uloženy jako jejich bitový součet. Jednotlivých schopností jsou definovány ve výčtu LSystemCapabilities. 
      </para>
      <para>
        Vytvoření nejvhodnější instance usnadňuje statická metoda AbstractGenerator::createLSystem(), jež na základě typu načteného souboru automaticky vytvoří a vrátí vhodnou instanci L-systému. Testování, zda daný typ L-systému vyhovuje, zde probíhá od nejrychlejšího typu algoritmu k nejpomalejšímu. První typ, který splňuje všechny požadavky, je vybrán a použit. 
      </para>
    </sect2>
    <sect2 id="sec050402">
      <title>Inicializační fáze</title>
      <para>
        Pravidla, která jsou předána jako řetězce, jsou zde v této fázi konvertována do struktury Rule. Ke konverzi slouží trojice metod. Metoda setAxiom() jednoduše přeloží řetězec znaků na vnitřní formát slova a nastaví jej jako počáteční slovo typu LongString pro iterační proces. 
      </para>
      <para>
        Nezbytnou součástí jsou metody pro přidání přepisovacích pravidel a homomorfismů. Struktura i funkce jsou u addRule() a addHomomoprhism() dosti podobné. Způsob zpracování je v případě předchůdce shodný. Lišit se může zpracování následníka. Zpracování pravidel probíhá voláním jednotlivých funkcí struktury Rule, čímž se postupně prochází řetězec pravidla a instance struktury Rule je automaticky nastavována. Následující pseudokód ukazuje, jakým způsobem je zpracováno například pravidlo parametrického stochastického 0L-systému.
      </para>
      <para>
        <programlisting><![CDATA[
přidejPřepisovacíPravidlo( řetězec pravidlo )
{
      
}
     ]]></programlisting>
      </para>
    </sect2>
    <sect2 id="sec050403">
      <title>Přepisovací fáze</title>
      <para>
        Jednoznačně nejdůležitější fází je samotný iterační proces. Probíhá v krocích po jednotlivých iteracích. Začíná vždy s počátečním slovem, axiomem, v němž jsou při první iteraci všechny moduly nahrazeny dle přepisovacích pravidel. Tento postup se opakuje při každé iteraci na nově vzniklých slovech. Celý proces přepisu je zjednodušeně zobrazen v následujícím pseudokódu. 
      </para>
      <para>
        <programlisting><![CDATA[
LongString puvodniSlovo;
LongString noveSlovo;
for( všechny moduly v puvodniSlovo )
{
    najdi všechny pravidla, které mají aktuální modul jako předchůdce;
    if( existuje alespoň jedno takové)
    {
        if(vyber pravidlo)
        {
            noveSlovo.připoj( vygeneruj následníka modulu);
        }
        else
        {
            noveSlovo.připoj(použij pro daný modul pravidlo identity);
        }
    }
    else
    {
         noveSlovo.připoj(použij pro daný modul pravidlo identity);
    }
}
     ]]></programlisting>
      </para>
      <para>
        Prvotní prohledání pravidel vybere pouze ty, které mají aktuální modul jako svého předchůdce. Takových pravidel může být hned několik. Mohou se lišit v kontextu, podmínce nebo mohou být vybrány na základě pravděpodobnosti. Výběr jednoho pravidla z množiny provádí metoda selectRule(), v pseudokódu označená jako "vyber slovo". Právě toto je funkce v níž se jednotlivé L-systémy mohou nejvíce lišit a kde lze implementovat různé typy funkcionalit pro výběr pravidla. Detaily výběru pravidla u jednotlivých L-systémů rozebírá kapitola LINK. Pokud žádné z pravidel nevyhovuje, použije se pravidlo identity, které pouze zkopíruje modul do nově vznikajícího slova. Vkládání do nového slova probíhá výhradně připojováním na jeho konec.  
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0505">
    <title>Rozdělení L-systémů</title>
    <para>
      Jak již bylo zmíněno v kapitole XX o typech větvených struktur, je nutné pro modelování pokročilejších botanických organismů použít složitější typy L-systémů. Zároveň však není kvůli optimalizaci vhodné použít stejných L-systémů pro generování jednoduchých struktur. Navíc mají různé typy L-systémů různé formy zápisů svých přepisovacích pravidel. V následující kapitole jsou popsány jednotlivá specifika implementace jednotlivých typů L-systémů a také formáty zápisů pravidel, jež tyto systémy zpracovávají. Jsou zde rozebrány pouze vlastnosti které nebyly společné a tak byly v minulé kapitole LINK zmíněny jen okrajově.
    </para>
    <sect2 id="sec050501">
      <title>D0L-systémy</title>
      <para>
        Nejjednodušším L-systémem je tato varianta implementovaná třídou D0LSystem. Jak již název napovídá zpracovává tato třída pouze deterministické bezkontextové L-systémy. Pro řadu modelů je tento typ generování dostatečný. Navíc je díky své jednoduchosti nejrychlejší. Zápis pravidel je ukázán na následujícím vzorovém příkladu.
      </para>
      <para>
        <programlisting><![CDATA[
A->A+(10)FBF
     ]]></programlisting>
      </para>
      <para>
        Tento typ tedy nepodporuje zpracování výrazů. Každý následník se tedy skládá pouze z jednoho řetězce typu StaticString. Iterační proces je v tomto případě vcelku jednoduchý. Vždy existuje maximálně jedno pravidlo, jehož předchůdce odpovídá právě zpracovávanému modulu původního řetězce. Toto pravidlo je také vždy vybráno a jeho následník je použit při přepisu.
      </para>
    </sect2>
    <sect2 id="sec050502">
      <title>Parametrické stochastické bezkontextové L-systémy</title>
      <para>
        Tento typ L-systému umožňuje zpracovat parametrické i stochastické L-systémy, čímž značně rozšiřuje škálu možností. Díky parametrům lze vytvořit i mezotonické a akrotonické struktury. Náhodnost pak dovoluje vytvářet rostlinné organismy s rozdílnou a náhodnout strukturou, jež však mají společné rodové znaky. Jsou implementovány ve třídě ParStoch0LSystem. Tato třída zpracovává L-systémy ve tvaru, jak je popisuje kapitola LINK. Příkladem mohou být následující pravidla zapsané již v podobě, jež je tímto L-systémem zpracovatelná.
      </para>
      <para>
        <programlisting><![CDATA[
A(x,y):(x>y)->A(x-1,y)FB(y/2)F:(x*y)
     ]]></programlisting>
      </para>
      <para>
        Jednotlivé části tohoto řetězce mají následující význam.
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara>A(x,y) označuje předchůdce pravidla se dvěmi parametry x a y. Tento údaj je povinný, 
            </simpara>
          </listitem>
          <listitem>
            <simpara>(x>y) je příklad podmínky. Pokud pravidlo podmínku neobsahuje, může být podmínka nahrazena symbolem *, který značí, že je podmínka splněna vždy. 
            </simpara>
          </listitem>
          <listitem>
            <simpara>Následník A(x-1,y)FB(y/2)F bude rozdělen a zpracován do struktury Rule
            </simpara>
          </listitem>
          <listitem>
            <simpara>(x*y) je pravděpodobnostní faktor. Pokud se jedná o deterministické pravidlo, lze tento výraz vynechat a ukončit pravidlo posledním znakem následníka. V takovém případě je však nutné, aby žádné z pravidel s tímto předchůdcem neobsahovalo pravděpodobnostní faktor.
            </simpara>
          </listitem>
        </itemizedlist>      
      </para>
      <para>
        Výběr konkrétního pravidla provádí přetížená virtuální metoda selectRule(), která na vstupu obdrží už jen pravidla se shodujícím se předchůdcem. Tyto pravidla je nutné dále protřídit. Pokud se nejedná o stochastický L-systém vybere se pravidlo, které splňuje svou podmínku. V případě stochastického L-systému je běžné, že podmínku splňuje několik pravidel. Zde je zapotřebí vyhodnotit jejich pravděpodobnostní faktory a výsledky pak předat instanci pomocné třídy RandomIndex. Ta na základě těchto faktorů vybere náhodně jedno z pravidel, které je použito pro přepis.
      </para>
    </sect2>
    <sect2 id="sec050503">
      <title>Parametrické stochastické kontextové L-systémy</title>
      <para>
        Aby byl zásuvný modul schopen zpracovávat dotazy a signály, obsahuje také třídu pro zpracování kontextových L-systémů. Použití kontextu také znamená jiný zápis pravidel.
      </para>
      <para>
        <programlisting><![CDATA[
A(x,y) < B(z) > C(a,b,c) : (x + z > abs(a-c)) -> B(b-1)FA(x/2,y/2) : max(0, 1-1/z*z)
     ]]></programlisting>
      </para>
      <para>
        Oproti bezkontextovým gramatikám se zde navíc zadává levý a pravý kontext. Jeho zadání lze vynechat, avšak znaménka &lt; a > je nutné v řetězci pravidla zachovat. Zpracování podmínky i pravděpodobnostního faktoru je zde obdobné jako u bezkontextových L-systémů.    
      </para>
      <para>
        Nejdůležitějším rozšířením je schopnost ověřovat kontext předchůdce. Ověřování kontextu se řídí pravidly popsanými v kapitole o kontextových L-systémech LINK. Pro tuto činnost byly implementovány metody matchRight() a matchLeft(). Jde o metody třídy LongString a vrací hodnotu int, která informuje zda bylo ověřování úspěšné. V případě úspěchu vrací tyto metody pozici úspěšně ověřeného modulu, jinak vrací -1. Metody instance třídy LongString tedy dostanou informace, jaký kontext a kde jej ověřovat a poté samy vyhodnotí výsledek. Jak vyplývá z výše zmíněných pravidel, je potřeba u L-systémů se závorkami provádět někdy ověření na více místech zároveň. Jedná se například o situaci symbolu vedle závorky nebo pokud je sousední symbol v seznamu ignorovaných znaků. Ověřovací metody tak uvnitř obsahují rekurzivní volání sebe sama, aby všechny tyto situace byly korektně vyhodnoceny. Pokud dochází při ověřování k větvení, je většinou nutné naleznout v řetězci správná místa pro ověření kontextu tak, aby byla respektována skutečná topologie modelu. K tomuto účelu slouží metody findMatchingRightBracket() a findMatchingLeftBracket(), které k nalezené závorce najdou její protějšek. Tímto umožní ověřovacímu mechanismu pokračovat za závorkou. Pseudokód fungování metody matchRight() zjednodušeně ukazuje princip fungování této metody. U metody matchLeft() je princip obdobný.
      </para>
      <para>
        <programlisting><![CDATA[
int matchRight( kontext,   /*symbol pravého kontextu*/
                        pozice     /*odkud hledat*/,
                        ignorovat /*seznam ignorovaných znaků*/ )
{
    if ( slovo[pozice] == '[' )
         return matchRight( kontext, pozice + 1, ignorovat )  ||
                   matchRight( kontext, findMatchingRightBracket(), ignorovat);
    else if (( slovo[pozice] == '[' ) || ( ignorovat obsahuje slovo[pozice] )
        return matchRight( kontext, pozice +1, ignorovat );
    else if ( slovo[pozice] == kontext )
        return pozice;
    else
        return -1;
}
     ]]></programlisting>
      </para>
      <para>
        Levý i pravý kontext může stejně jako předchůdce mít své parametry, které je nutné načíst pro zpracování výrazů. Tyto parametry se načtou z řetězce slova díky pozicím modulů získaných během ověřování kontextu. Díky rozšíření o zpracování kontextu mohl být do zásuvném modulu implementován také mechanismus pro zpracování dotazů. Podrobnějším popisem implementace dotazů se zabývá kapitola LINK.
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec0506">
    <title>Dotazy</title>
    <para>
      Díky nim lze již během generování zjistit, kde a v jaké poloze se bude daný modul nacházet v prostoru. Díky rozšířitelnosti knihovny FunctionParser mohly být přidány do výrazů funkce, jež kterýkoli parametr polohy želvy vrátí. Toto připojení uživatelsky definovaných funkcí je prováděno pouze do výrazů které tyto funkce obsahují. Je to z důvodu, že výrazy, které tyto funkce obsahují, nemohou být optimalizovány vnitřními algoritmy knihovny FunctionParser. Tyto funkce jsou ve skutečnosti statickými metodami třídy Query. Každá tato metoda je bezparametrická a vrací hodnotu double. Pro každou souřadnici každého vektoru tedy existuje jedna metoda. 
    </para> 
    <para>
      Třída Query však slouží pouze jako adaptér mezi třídami FunctionParser a QueryInterpret, což je speciálně uzpůsobený interpret pro zpracování dotazů. Jeho fungování je podobné jako u třídy pro intepretaci geometrie, jež bude popsána v kapitole LINK. Narozdíl od ní však nevytváří žádnou geometrii a intepretuje jen symboly, které jsou důležité pro polohu želvy. Je implementován dle návrhového vzoru jedináček. 
    </para>
    <para>
      Na základě volání některé z metod třídy Query pak dostane pokyn k interpretaci slova. Interpretována je vždy jen ta část slova, která předcházela právě zpracovávanému modulu s dotazy. Nakonci interpretace je poloha želvy uložena a připravena pro dotazovaní metody. Celá tato operace získání polohy je zajišťována vnitřní metodou update(). Problémem je, že hodnoty polohy želvy velice rychle stárnou a jejich obnovení je kvůli nutnosti interpretace řetězce časově náročná procedura. Pro omezení volání metody update je implementován jednoduchý algoritmus. Je založen na principu, že pokud je některá souřadnice přečtena podruhé, jedná se o jiný modul a je tedy třeba provést obnovu. Na obrázku lze vidět, jakým způsobem vypadá pravidlo s dotazy a jak se jednotlivé dotazy pomocí instance třídy QueryInterpret vyhodnocují. U dotazů, které si vynutí provedení interpretace slova je spolu s důvodem uvedena metoda update(). Ostatní dotazy obdrží odpověď okamžitě. 
    </para>
    <para>
      
    </para>
    <para>
      Instance třídy QueryInterpret tedy při prvním volání dotazu positionX() zjistí všechny souřadníce polohy želvy. Poté je možné vracet jednotlivé souřadnice polohy. Jakmile se jeden z dotazů zopakuje, provede se obnova polohy želvy a tedy i nová interpretace želvy. Stejným způsobem reaguje interpret na dotazy týkající se aktuálních směrových vektorů želvy.
    </para>
    <para>
      Zpracováním dotazů lze tedy do řetězce slova dostat poziční hodnoty ještě před fází vykreslování. Kombinací s kontextovými pravidly s pomínkou lze dosáhnout toho, že některá pravidla budou použita jen při urcčitých hodnotách těchto dotazů. Druhou možností je využít tyto hodnoty ke změně parametrů modulů pravidla. Například v případě popinavých rostlin lze na základě polohy a směru rostoucí větve vyhodnotit, kterým směrem by se měla daná větev vyvíjet a podle toho pak ovlivnit její směr.
    </para>  
  </sect1>
  <sect1 id="sec0507">
    <title>Podřízené L-systémy</title>
    <para>
      Problematiku návrhu modelu pomocí L-systémů lze rozdělit na několik úrovní. Pro lepší kontrolu, přehlednost a také nastavitelnost je lepší jednotlivé dílčí celky hiearchicky seřadit. U botanických organismů se může jednat například o rozdělení na rostlinné orgány. Jde však jí samozřejmě i hlouběji. Výhodou tohoto přístupu je modularita. Každý takovýto dílčí L-systém má svá vlastní nastavení a může být použit v libovolném počtu jiných L-systémů. Pokud tedy vytvořím L-systém pro list, je velice jednoduché přidat jej jako podsystém ke všem L-systémům stromů stejného druhu.  
    </para> 
    <para>
      Každý L-systém si své podsystémy spravuje sám. Po jejich načtení pomocí metod třídy AbstractFile je každý L-systém inicializován a zpracován podobně jako ve třídě LSystemGenerator. Každému podsystému je přiřazeno unikátní číslo. Pod ním je tento systém reprezentován v řetězci pomocí modulu #( L-System_ID ). Všechna slova jsou vygenerována a ponechána uložena v nadřazeném L-systému. Do řetězce jsou vložena až po ukončení iteračního procesu, kdy jsou všechny moduly #( ) nahrazeny vygenerovanými slovy. Na začátku a konci každého slova podsystému jsou speciální moduly $, jež poté informují intepret o změně L-systému, který pak dle parametrů tohoto modulu přepne na zpracování řetězce dle odpovídajících nových parametrů. Neboť je toto chování dosti podobné zpracování závorkám, věnuje se jim společná kapitola o implementaci zásobníku LINK. 
    </para>
  </sect1>
</chapter>
<chapter id="ch06">
  <title>Generovaní slov pro modely rostlin</title>
  <para>
    Předchozí kapitola se věnovala výhradně iteračnímu procesu L-systémů za účelem vytvoření slova, jež bude reprezentovat požadovaný model. V této kapitole budou podrobněji rozvedeny techniky, které takto vygenerované slovo intepretují a vytváří tak jeho geometrickou podobu. Pro intepretaci byla zvolena výše zmíněná technika želví grafiky. Jednotlivé moduly pak slouží jako příkazy želvě k různým úkonům. Díky abstrakci na úrovni modulů lze vybírat z různých technik, kterými želva kreslí, a tak vytvářet rozmanitější modely.
  </para>
  <para>
    Kromě samotné geomterie je nutné řešit i jiné otázky týkající se zobrazení modelu. Jedná se zejména o mapování textur a o úroveň detailů. Na této vrstvě je také možné přidat i různé vlivy okolí. Jelikož se jedná již pouze o intepretaci, tyto vlivy nijak nemohou ovlivnit strukturu výsledného modelu. Mohou však globálně ovlivnit celý model. Lze tak jednoduše přidat modelu závislost na některých silách, jako je gravitace. Jinou možností je přiblížení rostlin svým reálným předlohám pomocí malé náhodnosti úhlů. Modely tak ztratí svou viditelnou matematickou přesnost.
  </para>
  <para>
    Pro interpretaci slov slouží abstraktní třída AbstractInterpret. Implementováni jsou dva potomci. GeometryInterpret zpracovává věškeré příkazy želvy a slouží k vytváření geometrie. QueryIntepret provádí zpracování dotazů ohledně polohy želvy. Tento interpret zpracovává jen vybrané příkazy. Podrobněji byl popsán v kapitole LINK.  
  </para>
  <para>
    Řetězec generovaný L-systémem je přetypován na nový typ. Z intstance třídy LongString je konvertován na instanci třídy ParseableString. Jedná se o jednoduchou třídu, která obsahuje metody pro dopředné procházení řetězcem a získávání parametrů.
  </para>
  <sect1 id="sec0601">
    <title>Spojení s grafem scény</title>
    <para>
      Pro zobrazení generované geometrie je důležité napojení na graf scény. Při vytváření interpretu je mu kontruktorem předán ukazatel na rodiče v grafu. Vzhledem k tomu, že slovo může díky mechanismu podsystémů obsahovat řetězce několika L-systémů mající různé parametry, je nutné i při vytváření geometrie tyto L-systémy oddělit. Díky grafu scény je k dispozici ideální řešení. Pro každý L-systém vytvoří interpret jeden uzel s geometrií, jež bude obsahovat i svá nastavení. Tyto uzly jsou instancemi třídy LSGeode. Tato třída je rozšířením třídy osg::Geode. Navíc obsahuje metody pro volbu správného typu želvy pro generování geometrie a také metody pro předání výchozích hodnot nastavení želvy. Všechny tyto hodnoty jsou získány z parametrů, jež se načítají při zpracování souborů L-systémů potomky třídy AbstractFile LINK.  
    </para> 
    <para>
      Při inicializaci instance LSGeode dochází také k nastavení uzlu. Nastaví se textura, materiály a další vlastnosti. Veškeré parametry jsou zpracovány a konvertovány do takové podoby, aby při generování byly buď již nastaveny nebo rychle připraveny ke zpracování.
    </para>
  </sect1>
  <sect1 id="sec0602">
    <title>Interpretace pomocí želví grafiky</title>
    <para>
        
    </para> 
    <sect2 id="sec060201">
      <title>Zásobník pro ukládání želvích instancí</title>
      <para>
        Pro zpracování slov, které obsahují závorky a podsystémy, je nutná dobrá implementace zásobníku pro želvy. K tomuto účelu slouží třída TurtleStack, která poskytuje standardní funkce zásobníku. Je však uzpůsobena pro použití v tomto zásuvném modulu. Při procházení řetězce a interpretaci jednotlivých modulů se operace prov
K operacím na zásobníku dochází v případě některých speciálních symbolů. 
      </para> 
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara>[ - Tato závorka označuje počátek nové větve. Je tedy nutné vytvořit na zásobníku metodou push() novou želvu, která se vykreslováním této větve bude zabývat. Parametry i typ si tato želva nastaví podle želvy na vrcholu zásobníku.
            </simpara>
          </listitem>
          <listitem>
            <simpara>] - Ukončení větve je signalizováno tímto symbolem. Želva je z vrcholu zásobníku odstraněna a v generování dále pokračuje želva pod ní.
            </simpara>
          </listitem>
          <listitem>
            <simpara>$(x) - Jednotlivé L-systémy mají již od svého načtení přiřazen jednoznačný identifikátor. Symbol dolaru s jedním parametrem oznamuje intepreteru, že má dojiít ke změně L-systému. Podle identifikátoru v parametru modulu se zvolí správný L-systém a jeho odpovídající uzel s geometrií LSGeode. Ten už poté ví, který typ želvy použít a jaké ji nastavit výchozí parametry. Některé parametry, jako je matice polohy, mohou být nastaveny podle želvy na vrcholu zásobníku. S novou želvou se pak na zásobníku provede operace push(). 
            </simpara>
          </listitem>
          <listitem>
            <simpara>$ - Ukončení slova podsystému signalizuje symbol dolaru bez parametru. Z vrcholu zásobníku je odstraněna želva a ve vykreslování tak pokračuje želva nadřazeného L-systému. 
            </simpara>
          </listitem>
        </itemizedlist> 
      </para>
    </sect2>
    <sect2 id="sec060202">
      <title>Želví rozhraní</title>
      <para>
        Pro větší modularitu byl zvolen při návrhu model, jež umožňuje použití libovolného množství typů želv. Lze tedy generovat různou geometrii pomocí stejných mechanismů. Všechny třídy želv dědí z abstraktní třídy AbstractTurtle. Tato třída obsahuje rozhraní pro úplnou kontrolu želvy. Většinu tvoří metody pro zpracování všech příkázů, které se ve slovech vyskytují jako moduly. Kromě toho obsahuje metody pro propojení s uzlem geometrie. Do něj pak přímo ukládá veškerou geometrii. K propojení dochází při vkládání želvy na vrchol zásobníku. Je zde k dispozici i několik metod pro vykreslování pomocné geometrie při ladění.
      </para>
      <para>
        Každá želva má celou řadu parametrů, jež se mohou během vykreslování neustále měnit. Proto obsahuje strukturu TurtleProperties, která všechny tyto hodnoty uchovává. Tyto parametry si želvy mezi sebou předávájí při operacích na zásobníku. Jinou možností nahrání výchozích parametrů z instance třídy LSGeode.
      </para>
    </sect2>
    <sect2 id="sec060203">
      <title>Želví příkazy</title>
      <para>
        Každá želva intepretuje celou řadu příkazů. Ne všechny želvy musí nutně implementovat všechny příkazy. Některé mohou být velice úzce specializované a mít implementováno jen několik příkazů. Obecně však lze příkazy rozdělit do několika kategorií. 
      </para> 
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <simpara>Základní pohybové příkazy - Většina želv má implementovány základní příkazy pro pohyb. Metody pro pohyb jsou společné a nachází se v abstraktní třídě MovingTurtle. Umožňují například pohyb želvy dopředu a natáčení kolem všech os. Želva se může pohybovat i bez generování geometrie pouze za účelem přemístění se.
            </simpara>
          </listitem>
          <listitem>
            <simpara>Pokročilé pohybové příkazy - Jedná se o nestandardní pohyby želvy, jako je otočení do protisměru, vyrovnání náklonu do vodorovné polohy nebo náhodné otočení v libovolném směru.
            </simpara>
          </listitem>
          <listitem>
            <simpara>Změna stavových proměnných - Řadu parametrů želvy lze během intepretace měnit. Je tak možné například prodloužit délku kroku nebo měnit výchozí úhel rotace.
            </simpara>
          </listitem>
          <listitem>
            <simpara>Nastavení vnějších vlivů - Některé příkazy mohou ovlivnit reakci dané želvy na globální vnější vlivy. V případě gravitace se může například jednat o změnu pružnosti větve. 
            </simpara>
          </listitem>
        </itemizedlist> 
      </para>
    </sect2>
  </sect1>
</chapter>

<bibliography>
   <biblioentry>
      <abbrev>OpenGL</abbrev>
      <authorgroup>
         <author>
           <firstname>Dave</firstname>
           <surname>Shreiner</surname>
         </author>  
         <author>
           <firstname>Mason</firstname>
           <surname>Woo</surname>
         </author>
         <author>
           <firstname>Jackie</firstname>
           <surname>Neider</surname>
         </author>
         <author>
           <firstname>Tom</firstname>
           <surname>Davis</surname>
         </author>
      </authorgroup>
      <title>OpenGL Průvodce programátora</title>    
      <publisher>
         <publishername>Computer Press, a.s.</publishername>
      </publisher>
      <pubdate>2006</pubdate>
      <isbn>80-251-1275-6</isbn>
   </biblioentry>
   
   <biblioentry>
      <abbrev>mpg</abbrev>
      <authorgroup>
         <author>
           <firstname>Jiří</firstname>
           <surname>Žára</surname>
         </author>  
         <author>
           <firstname>Bedřich</firstname>
           <surname>Beneš</surname>
         </author>
         <author>
           <firstname>Jiří</firstname>
           <surname>Sochor</surname>
         </author>
         <author>
           <firstname>Petr</firstname>
           <surname>Felkel</surname>
         </author>
      </authorgroup>
      <title>Moderní počítačová grafika</title>    
      <publisher>
         <publishername>Computer Press, a.s.</publishername>
      </publisher>
      <pubdate>2004</pubdate>
   </biblioentry>
   
   <biblioentry>
      <abbrev>CAD history</abbrev>
      <authorgroup>
         <author>
           <firstname>Marian</firstname>
           <surname>Bozdoc</surname>
         </author>  
      </authorgroup>
      <title>iMB The History of CAD</title>    
      <publisher>
         <publishername>MB Solutions</publishername>
      </publisher>
      <pubdate>2004</pubdate>  
      <releaseinfo>Dokument dostupný na 
         <ulink url="http://mbinfo.mbdesign.net/CAD-History.htm"></ulink> (leden 2008)
      </releaseinfo>
   </biblioentry>
   
   <biblioentry>
      <abbrev>CAD</abbrev>
      <authorgroup>
         <author>
           <firstname>Michal</firstname>
           <surname>Fischer</surname>
         </author>  
         <author>
           <firstname>Petr</firstname>
           <surname>Vaněk</surname>
         </author>
      </authorgroup>
      <title>CAD I-V</title>    
      <publisher>
         <publishername>e-Architekt.cz</publishername>
      </publisher>
      <pubdate>2004</pubdate>   
      <releaseinfo>Seriál dokumentů dostupný na 
      <ulink url="http://www.e-architekt.cz/"></ulink> (leden 2008)</releaseinfo>
   </biblioentry>
   
   <biblioentry>
      <abbrev>scanline</abbrev>
      <authorgroup>
         <author>
           <firstname>Robert R.</firstname>
           <surname>Snapp</surname>
         </author>  
      </authorgroup>
      <title>Scanline Fill Algorithm</title>    
      <publisher>
         <publishername>Department of Computer Science, University of Vermont</publishername>
      </publisher>
      <pubdate>2003</pubdate>   
      <releaseinfo>Dokument dostupný na 
         <ulink url="http://www.cs.uvm.edu/~snapp/teaching/CS274/lectures/scanlinefill.pdf"></ulink> (leden 2008)
      </releaseinfo>
   </biblioentry>
   
   <biblioentry>
      <abbrev>adv oGL</abbrev>
      <authorgroup>
         <author>
           <firstname>Tom</firstname>
           <surname>McReynolds</surname>
         </author>  
         <author>
           <firstname>David</firstname>
           <surname>Blythe</surname>
         </author> 
      </authorgroup>
      <title>Advanced Graphics Programming Techniques Using OpenGL</title>    
      <publisher>
         <publishername>Elsevier Inc.</publishername>
      </publisher>
      <pubdate>2005</pubdate>
      <isbn>1-55860-659-9</isbn> 
      <releaseinfo>Dokument dostupný na adrese
         <ulink url="http://web.informatik.uni-bonn.de/II/ag-klein/global/proseminar_ss2001/course12.pdf"></ulink> (leden 2008)
      </releaseinfo>
   </biblioentry>
   
   <biblioentry>
      <abbrev>oGL bible</abbrev>
      <authorgroup>
         <author>
           <firstname>Richard S.</firstname>
           <surname>Wright</surname>
         </author>  
         <author>
           <firstname>Benjamin</firstname>
           <surname>Lipchak</surname>
         </author> 
      </authorgroup>
      <title>OpenGL Super Bible</title>    
      <publisher>
         <publishername>Macmillan Computer Publishing</publishername>
      </publisher>
      <pubdate>1996</pubdate>
      <isbn>1-57169-073-5</isbn>
   </biblioentry>
   
   <biblioentry>
      <abbrev>nehe</abbrev>
      <authorgroup>
         <author>
           <firstname>Michal</firstname>
           <surname>Turek</surname>
         </author>  
      </authorgroup>
      <title>CZ NeHe OpenGL</title>    
      <publisher>
         <publishername>Michal Turek</publishername>
      </publisher>
      <pubdate>2004</pubdate>
      <releaseinfo>Dokument dostupný na 
         <ulink url="http://nehe.ceske-hry.cz/download/download/cz_nehe_opengl.pdf"></ulink> (leden 2008)
      </releaseinfo>
   </biblioentry>

</bibliography>

<appendix id="appA">

</appendix>

</book>