#ifndef ABSTRACTTURTLE_H_
#define ABSTRACTTURTLE_H_

#include "utils.h"
#include "lsgeode.h"
#include "randomizer.h"

namespace AP_LSystem {
//class LSGeode;
//struct TurtleProperties;

enum InterpretErrorCodes
{
	LS_OK,
	LS_NOTDEFINED,
	LS_ERR_PAR_BADTYPE,
	LS_ERR_PAR_INVALIDCOUNT,
	LS_ERR_DRAWFORWARD_NEGATIVEDISTANCE,
	LS_ERR_STACK_UNKNOWN_TURTLE_TYPE,
	LS_ERR_STACK_NULL_LSGEODE,

};

const osg::Vec3d HeadVec(0.0,1.0,0.0);
const osg::Vec3d UpVec(1.0,0.0,0.0);
const osg::Vec3d LeftVec(0.0,0.0,1.0);
const osg::Vec3d Center(0.0,0.0,0.0);

const osg::Vec4d White(1.0,1.0,1.0,1.0);

/**
 *	Abstract class for all turtles with declarations of all necessary functions.
 */
class AbstractTurtle
{
protected:
	TurtleProperties properties;	///< properties of turtle is used for getting parameters for generation of geometry
	LSGeode * geode;				///< all geometry generated by turtle is stored to this output geode	

public:
//****************************************************************
//**						OTHER								**
//****************************************************************
	virtual int initialize()	{ return 0;}			///< initialize turtle
	virtual int finalize()		{ return 0;}
	virtual int resetValues() { return 0;}//TODO	///< reset all values in properties to default value as set in Configuration
	inline TurtleProperties & getProperties()	///< get Properties reference
	{
		return properties;
	}

	virtual void setProperties( TurtleProperties p )	///< set Properties of turtle. Must be part of turtle initialization
	{
		properties = p;
	}

	virtual void inheritProperties( TurtleProperties p ) ///> defines which properties shoul be inherited from parent to sub-system turtle
	{
		// inherit matrix
		properties.matrix = p.matrix;
	}

	inline void bindGeode( LSGeode * geode )	///< bind output geode with current turtle 
	{
		this->geode = geode;
	}

	inline LSGeode * getGeode( )
	{
		return geode;
	}

	inline osg::Matrixd getMatrix()
	{
		return properties.matrix;
	}

//****************************************************************
//**						DEBUG								**
//****************************************************************

	virtual void drawFrame( osg::Matrixd &, osg::Vec4d * = NULL )				= 0;
	virtual void drawVector( const osg::Vec3d & vector, osg::Matrixd & matrix, osg::Vec4d & color)
	{
		double s = properties.debugGeometryScale;
		double l = vector.length();
		osg::Cylinder * cylinder = new osg::Cylinder(vector * s * (l/2.0f) * matrix,s * 0.01f,s * l);
		osg::Cone * cone = new osg::Cone(vector * s * ( l + 0.03f ) * matrix, s * 0.03f,s * 0.15f);

		osg::Matrixd m = osg::Matrixd::rotate( LeftVec, vector ) * matrix;
		cylinder->setRotation( m.getRotate() );
		cone->setRotation( m.getRotate() );

		osg::ShapeDrawable * shape;
		shape = new osg::ShapeDrawable(cylinder);
		shape->setColor( color );
		geode->addDrawable( shape );
	
		shape = new osg::ShapeDrawable(cone);
//		shape->setColor( color );
		geode->addDrawable( shape );
	}

//****************************************************************
//**						ROTATION							**
//****************************************************************
	inline double toRad( double angle )
	{
		if( properties.flags & TurtleProperties::DEGREES_TO_RADIANS )
			return osg::DegreesToRadians( angle );
		else
			return angle;
	}

	inline double rand( double angle )
	{
		if( properties.angleVariance )
			angle *= Randomizer::get( properties.angleVariance );
		return angle;
	}

	virtual int turnLeft(std::vector<Parameter> &)			= 0;
	virtual int turnRight(std::vector<Parameter> &)			= 0;
	virtual int pitchDown(std::vector<Parameter> &)			= 0;
	virtual int pitchUp(std::vector<Parameter> &)			= 0;
	virtual int rollLeft(std::vector<Parameter> &)			= 0;
	virtual int rollRight(std::vector<Parameter> &)			= 0;

	virtual int turnArround()								= 0;
	virtual int rollArround()								= 0;
	virtual int rollUntilHorizontal()						= 0;
	virtual int randomTurnPitchRoll(std::vector<Parameter>&)= 0;

//****************************************************************
//**				    CHANGE PROPERTIES						**
//****************************************************************
	virtual int multiplyLength(std::vector<Parameter> &)	= 0;
	virtual int multiplyRadius(std::vector<Parameter> &)	= 0;
	virtual int multiplyAngle(std::vector<Parameter> &)		= 0;
	virtual int multiplyTropismElasticity(std::vector<Parameter> &)= 0;
	virtual int multiplyGravitropismElasticity(std::vector<Parameter> &)= 0;

//****************************************************************
//**						MOVEMENT							**
//****************************************************************

	virtual int drawForward(std::vector<Parameter> &)		= 0;
	virtual int drawForwardHalf()							= 0;
	virtual int moveForward(std::vector<Parameter> &)		= 0;
	virtual int moveForwardHalf()							= 0;
	
};
}

#endif