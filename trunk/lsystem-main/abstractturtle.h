#ifndef ABSTRACTTURTLE_H_
#define ABSTRACTTURTLE_H_

#include "utils.h"
#include "lsgeode.h"
#include "randomizer.h"

namespace AP_LSystem {

/**
  * Error codes that returns methods during interpretation. Error codes are used instead of exception because
  * of higher performance.
  */
enum InterpretErrorCodes
{
    LS_OK,                                  ///< OK. No error.
    LS_NOTDEFINED,                          ///< Method is not implemented.
    LS_ERR_PAR_BADTYPE,                     ///< Module has a different type
    LS_ERR_PAR_INVALIDCOUNT,                ///< Invalid count of module parameters
    LS_ERR_DRAWFORWARD_NEGATIVEDISTANCE,    ///< Forward step has a negative length
    LS_ERR_STACK_UNKNOWN_TURTLE_TYPE,       ///< Unknown turtle ID.
    LS_ERR_STACK_NULL_LSGEODE,              ///< TODO

};

const osg::Vec3d HeadVec(0.0,1.0,0.0);      ///< Turtle head vector
const osg::Vec3d UpVec(1.0,0.0,0.0);        ///< Turtle up vector
const osg::Vec3d LeftVec(0.0,0.0,1.0);      ///< Turtle left vector
const osg::Vec3d Center(0.0,0.0,0.0);       ///< Position of turtle

const osg::Vec4d White(1.0,1.0,1.0,1.0);    ///< White color

/**
 *	Abstract class for all turtles with declarations of all necessary functions.
 */
class AbstractTurtle
{
protected:
	TurtleProperties properties;	///< properties of turtle is used for getting parameters for generation of geometry
	LSGeode * geode;				///< all geometry generated by turtle is stored to this output geode	

public:
//****************************************************************
//**						OTHER								**
//****************************************************************
	virtual int initialize()	{ return 0;}			///< initialize turtle
	virtual int finalize()		{ return 0;}
	virtual int resetValues() { return 0;}//TODO	///< reset all values in properties to default value as set in Configuration

    /**
      * Returns turtle properties
      * @return properties
      */
    inline TurtleProperties & getProperties()
	{
		return properties;
	}

    /**
      * Sets turtle properties. The setup must be part of turtle initialization.
      * @param p properties
      */
    virtual void setProperties( TurtleProperties p )
	{
		properties = p;
	}

    /**
      * Inherits some properties. This method is called if different L-system is detected. This
      * subsystems has own properties, but some properties are inherited from the turtle on the stack.
      * @param p properties
      */
	virtual void inheritProperties( TurtleProperties p ) ///> defines which properties shoul be inherited from parent to sub-system turtle
	{
		// inherit matrix
		properties.matrix = p.matrix;
	}

    /**
      * Binds a turtle with LSGeode. During interpretation, the turtle will generate geometry to this
      * LSGeode.
      * @param geode Geode to be binded.
      */
	inline void bindGeode( LSGeode * geode )	///< bind output geode with current turtle 
	{
		this->geode = geode;
	}

    /**
      * Returns binded geode.
      * @return binded geode.
      */
	inline LSGeode * getGeode( )
	{
		return geode;
	}

    /**
      * Returns position matrix of turtle.
      * @return position matrix
      */
	inline osg::Matrixd getMatrix()
	{
		return properties.matrix;
	}

//****************************************************************
//**						DEBUG								**
//****************************************************************

	virtual void drawFrame( osg::Matrixd &, osg::Vec4d * = NULL )				= 0;
	virtual void drawVector( const osg::Vec3d & vector, osg::Matrixd & matrix, osg::Vec4d & color)
	{
		double s = properties.debugGeometryScale;
		double l = vector.length();
		osg::Cylinder * cylinder = new osg::Cylinder(vector * s * (l/2.0f) * matrix,s * 0.01f,s * l);
		osg::Cone * cone = new osg::Cone(vector * s * ( l + 0.03f ) * matrix, s * 0.03f,s * 0.15f);

		osg::Matrixd m = osg::Matrixd::rotate( LeftVec, vector ) * matrix;
		cylinder->setRotation( m.getRotate() );
		cone->setRotation( m.getRotate() );

		osg::ShapeDrawable * shape;
		shape = new osg::ShapeDrawable(cylinder);
		shape->setColor( color );
		geode->addDrawable( shape );
	
		shape = new osg::ShapeDrawable(cone);
//		shape->setColor( color );
		geode->addDrawable( shape );
	}

//****************************************************************
//**						ROTATION							**
//****************************************************************
	inline double toRad( double angle )
	{
		if( properties.flags & TurtleProperties::DEGREES_TO_RADIANS )
			return osg::DegreesToRadians( angle );
		else
			return angle;
	}

	inline double rand( double angle )
	{
		if( properties.angleVariance )
			angle *= Randomizer::get( properties.angleVariance );
		return angle;
	}

	virtual int turnLeft(std::vector<Parameter> &)			= 0;
	virtual int turnRight(std::vector<Parameter> &)			= 0;
	virtual int pitchDown(std::vector<Parameter> &)			= 0;
	virtual int pitchUp(std::vector<Parameter> &)			= 0;
	virtual int rollLeft(std::vector<Parameter> &)			= 0;
	virtual int rollRight(std::vector<Parameter> &)			= 0;

	virtual int turnArround()								= 0;
	virtual int rollArround()								= 0;
	virtual int rollUntilHorizontal()						= 0;
	virtual int randomTurnPitchRoll(std::vector<Parameter>&)= 0;

//****************************************************************
//**				    CHANGE PROPERTIES						**
//****************************************************************
	virtual int multiplyLength(std::vector<Parameter> &)	= 0;
	virtual int multiplyRadius(std::vector<Parameter> &)	= 0;
	virtual int multiplyAngle(std::vector<Parameter> &)		= 0;
	virtual int multiplyTropismElasticity(std::vector<Parameter> &)= 0;
	virtual int multiplyGravitropismElasticity(std::vector<Parameter> &)= 0;

//****************************************************************
//**						MOVEMENT							**
//****************************************************************

	virtual int drawForward(std::vector<Parameter> &)		= 0;
	virtual int drawForwardHalf()							= 0;
	virtual int moveForward(std::vector<Parameter> &)		= 0;
	virtual int moveForwardHalf()							= 0;
	
};
}

#endif
